{"id":"260216-ivory-plateau","workspaceRootPath":"~/Projects/wisper","sdkSessionId":"12ac8fce-de88-4f3a-b166-5ae114dd7d4b","sdkCwd":"~/Projects/wisper/sessions/260216-ivory-plateau","createdAt":1771300743440,"lastUsedAt":1771300743942,"lastMessageAt":1771300598729,"name":"Create new workspace skill","isFlagged":false,"lastReadMessageId":"msg-1771300743429-k3ezpw","enabledSourceSlugs":[],"permissionMode":"allow-all","llmConnection":"claude-max","connectionLocked":true,"thinkingLevel":"think","messageCount":12,"lastMessageRole":"assistant","preview":"npx skills add https://github.com/ehmo/platform-design-skills --skill macos-design-guidelines","tokenUsage":{"inputTokens":43112,"outputTokens":2466,"totalTokens":45578,"contextTokens":0,"costUsd":0.4499125,"cacheReadTokens":42496,"cacheCreationTokens":613,"contextWindow":200000},"lastFinalMessageId":"msg-1771300743429-k3ezpw"}
{"id":"msg-1771300598728-rc0sc1","type":"user","content":"<edit_request>\n<label>Add Skill</label>\n<file>/Users/andresilvagomez/Projects/wisper/skills/</file>\n<context>The user wants to add a new skill to their workspace. Skills are specialized instructions with a SKILL.md file containing YAML frontmatter (name, description) and markdown instructions. Ask clarifying questions if needed: What should the skill do? When should it trigger? Create the skill folder and SKILL.md in the workspace skills directory. Follow the patterns in ~/.craft-agent/docs/skills.md. After creating the skill, call skill_validate with the skill slug to verify the SKILL.md file.</context>\n</edit_request>\n\nnpx skills add https://github.com/ehmo/platform-design-skills --skill macos-design-guidelines","timestamp":1771300598728,"badges":[{"type":"context","label":"Add Skill","rawText":"<edit_request>\n<label>Add Skill</label>\n<file>/Users/andresilvagomez/Projects/wisper/skills/</file>\n<context>The user wants to add a new skill to their workspace. Skills are specialized instructions with a SKILL.md file containing YAML frontmatter (name, description) and markdown instructions. Ask clarifying questions if needed: What should the skill do? When should it trigger? Create the skill folder and SKILL.md in the workspace skills directory. Follow the patterns in ~/.craft-agent/docs/skills.md. After creating the skill, call skill_validate with the skill slug to verify the SKILL.md file.</context>\n</edit_request>\n\n","start":0,"end":629,"collapsedLabel":"Add Skill"}]}
{"id":"msg-1771300606697-emnhgi","type":"tool","content":"     1→# Skills Configuration Guide\n     2→\n     3→This guide explains how to create and configure skills in Craft Agent.\n     4→\n     5→## What Are Skills?\n     6→\n     7→Skills are specialized instructions that extend Claude's capabilities for specific tasks. They use **the exact same SKILL.md format as the Claude Code SDK** - making skills fully compatible between systems.\n     8→\n     9→**Key points:**\n    10→- Skills are invoked via slash commands (e.g., `/commit`, `/review-pr`)\n    11→- Skills can be automatically triggered by file patterns (globs)\n    12→- Skills can pre-approve specific tools to run without prompting\n    13→- The SKILL.md format is identical to what Claude Code uses internally\n    14→\n    15→## Same Format as Claude Code SDK\n    16→\n    17→Craft Agent uses **the identical SKILL.md format** as the Claude Code SDK. This means:\n    18→\n    19→1. **Format compatibility**: Any skill written for Claude Code works in Craft Agent\n    20→2. **Same frontmatter fields**: `name`, `description`, `globs`, `alwaysAllow`, `requiredSources`\n    21→3. **Same content structure**: Markdown body with instructions for Claude\n    22→\n    23→**What Craft Agent adds:**\n    24→- **Visual icons**: Display custom icons in the UI for each skill\n    25→- **Workspace organization**: Skills are scoped to workspaces\n    26→- **UI management**: Browse, edit, and validate skills through the interface\n    27→\n    28→## Skill Precedence\n    29→\n    30→When a skill is invoked (e.g., `/commit`):\n    31→\n    32→1. **Workspace skill checked first** - If `~/.craft-agent/workspaces/{id}/skills/commit/SKILL.md` exists, it's used\n    33→2. **SDK skill as fallback** - If no workspace skill exists, the built-in SDK skill is used\n    34→\n    35→This allows you to:\n    36→- **Override SDK skills** - Create a workspace skill with the same slug to replace built-in behavior\n    37→- **Extend SDK skills** - Reference SDK behavior in your custom skill and add workspace-specific instructions\n    38→- **Create new skills** - Add entirely new skills not in the SDK\n    39→\n    40→## Skill Storage\n    41→\n    42→Skills are stored as folders:\n    43→```\n    44→~/.craft-agent/workspaces/{workspaceId}/skills/{slug}/\n    45→├── SKILL.md          # Required: Skill definition (same format as Claude Code SDK)\n    46→├── icon.svg          # Recommended: Skill icon for UI display\n    47→├── icon.png          # Alternative: PNG icon\n    48→└── (other files)     # Optional: Additional resources\n    49→```\n    50→\n    51→## SKILL.md Format\n    52→\n    53→The format is identical to Claude Code SDK skills:\n    54→\n    55→```yaml\n    56→---\n    57→name: \"Skill Display Name\"\n    58→description: \"Brief description shown in skill list\"\n    59→globs: [\"*.ts\", \"*.tsx\"]     # Optional: file patterns that trigger skill\n    60→alwaysAllow: [\"Bash\"]        # Optional: tools to always allow\n    61→requiredSources:             # Optional: sources to auto-enable on invocation\n    62→  - linear\n    63→---\n    64→\n    65→# Skill Instructions\n    66→\n    67→Your skill content goes here. This is injected into Claude's context\n    68→when the skill is active.\n    69→\n    70→## Guidelines\n    71→\n    72→- Specific instructions for Claude\n    73→- Best practices to follow\n    74→- Things to avoid\n    75→\n    76→## Examples\n    77→\n    78→Show Claude how to perform the task correctly.\n    79→```\n    80→\n    81→## Metadata Fields\n    82→\n    83→### name (required)\n    84→Display name for the skill. Shown in the UI and skill list.\n    85→\n    86→### description (required)\n    87→Brief description (1-2 sentences) explaining what the skill does.\n    88→\n    89→### globs (optional)\n    90→Array of glob patterns. When a file matching these patterns is being worked on,\n    91→the skill may be automatically suggested or activated.\n    92→\n    93→```yaml\n    94→globs:\n    95→  - \"*.test.ts\"           # Test files\n    96→  - \"*.spec.tsx\"          # React test files\n    97→  - \"**/__tests__/**\"     # Test directories\n    98→```\n    99→\n   100→### alwaysAllow (optional)\n   101→Array of tool names that are automatically allowed when this skill is active.\n   102→Useful for skills that require specific tools without prompting.\n   103→\n   104→```yaml\n   105→alwaysAllow:\n   106→  - \"Bash\"                # Allow bash commands\n   107→  - \"Write\"               # Allow file writes\n   108→```\n   109→\n   110→### requiredSources (optional)\n   111→Array of source slugs to auto-enable when this skill is invoked.\n   112→When a user mentions the skill, the listed sources are enabled for the session\n   113→before the agent starts — so tools from those sources are available from the first turn.\n   114→\n   115→Sources must exist in the workspace and be authenticated. Unauthenticated or\n   116→missing sources are silently skipped (the existing runtime auto-enable handles them\n   117→as a fallback).\n   118→\n   119→```yaml\n   120→requiredSources:\n   121→  - linear               # Auto-enable Linear source\n   122→  - github               # Auto-enable GitHub source\n   123→```\n   124→\n   125→## Creating a Skill\n   126→\n   127→### 1. Create the skill directory\n   128→\n   129→```bash\n   130→mkdir -p ~/.craft-agent/workspaces/{ws}/skills/my-skill\n   131→```\n   132→\n   133→### 2. Write SKILL.md\n   134→\n   135→```markdown\n   136→---\n   137→name: \"Code Review\"\n   138→description: \"Review code changes for quality, security, and best practices\"\n   139→globs: [\"*.ts\", \"*.tsx\", \"*.js\", \"*.jsx\"]\n   140→---\n   141→\n   142→# Code Review Skill\n   143→\n   144→When reviewing code, focus on:\n   145→\n   146→## Quality Checks\n   147→- Consistent code style\n   148→- Clear naming conventions\n   149→- Appropriate abstractions\n   150→\n   151→## Security Checks\n   152→- Input validation\n   153→- Authentication/authorization\n   154→- Sensitive data handling\n   155→\n   156→## Best Practices\n   157→- Error handling\n   158→- Performance considerations\n   159→- Test coverage\n   160→```\n   161→\n   162→### 3. Add an icon (IMPORTANT)\n   163→\n   164→Every skill should have a visually relevant icon. This helps users quickly identify skills in the UI.\n   165→\n   166→**Icon requirements:**\n   167→- **Filename**: Must be `icon.svg`, `icon.png`, `icon.jpg`, or `icon.jpeg`\n   168→- **Format**: SVG preferred (scalable, crisp at all sizes)\n   169→- **Size**: For PNG/JPG, use at least 64x64 pixels\n   170→\n   171→**How to get an icon:**\n   172→\n   173→1. **Search online icon libraries:**\n   174→   - [Heroicons](https://heroicons.com/) - MIT licensed\n   175→   - [Feather Icons](https://feathericons.com/) - MIT licensed\n   176→   - [Simple Icons](https://simpleicons.org/) - Brand icons (git, npm, etc.)\n   177→\n   178→2. **Use WebFetch to download:**\n   179→   ```\n   180→   # Find an appropriate icon URL and download it\n   181→   WebFetch to get SVG content, then save to icon.svg\n   182→   ```\n   183→\n   184→3. **Match the skill's purpose:**\n   185→   - Git/commit skill → git icon or commit icon\n   186→   - Test skill → checkmark or test tube icon\n   187→   - Deploy skill → rocket or cloud icon\n   188→   - Review skill → magnifying glass or eye icon\n   189→\n   190→### 4. Validate the skill\n   191→\n   192→**IMPORTANT**: Always validate after creating or editing a skill:\n   193→\n   194→```\n   195→skill_validate({ skillSlug: \"my-skill\" })\n   196→```\n   197→\n   198→This validates:\n   199→- Slug format (lowercase, alphanumeric, hyphens only)\n   200→- SKILL.md exists and is readable\n   201→- YAML frontmatter is valid\n   202→- Required fields present (name, description)\n   203→- Content is non-empty\n   204→- Icon format (if present)\n   205→\n   206→## Example Skills\n   207→\n   208→### Commit Message Skill\n   209→\n   210→```yaml\n   211→---\n   212→name: \"Commit\"\n   213→description: \"Create well-formatted git commit messages\"\n   214→alwaysAllow: [\"Bash\"]\n   215→---\n   216→\n   217→# Commit Message Guidelines\n   218→\n   219→When creating commits:\n   220→\n   221→1. **Format**: Use conventional commits\n   222→   - `feat:` New feature\n   223→   - `fix:` Bug fix\n   224→   - `docs:` Documentation\n   225→   - `refactor:` Code refactoring\n   226→   - `test:` Adding tests\n   227→\n   228→2. **Style**:\n   229→   - Keep subject line under 72 characters\n   230→   - Use imperative mood (\"Add feature\" not \"Added feature\")\n   231→   - Explain why, not what (the diff shows what)\n   232→\n   233→3. **Co-authorship**:\n   234→   Always include: `Co-Authored-By: Claude <noreply@anthropic.com>`\n   235→```\n   236→\n   237→**Recommended icon**: Git commit icon from Heroicons or Simple Icons\n   238→\n   239→### Team Standards Skill\n   240→\n   241→```yaml\n   242→---\n   243→name: \"Team Standards\"\n   244→description: \"Enforce team coding conventions and patterns\"\n   245→globs: [\"src/**/*.ts\", \"src/**/*.tsx\"]\n   246→---\n   247→\n   248→# Team Coding Standards\n   249→\n   250→## File Organization\n   251→- One component per file\n   252→- Co-locate tests with source files\n   253→- Use barrel exports (index.ts)\n   254→\n   255→## Naming Conventions\n   256→- Components: PascalCase\n   257→- Hooks: camelCase with `use` prefix\n   258→- Constants: SCREAMING_SNAKE_CASE\n   259→\n   260→## Import Order\n   261→1. External packages\n   262→2. Internal packages (@company/*)\n   263→3. Relative imports\n   264→```\n   265→\n   266→**Recommended icon**: Clipboard list or checklist icon\n   267→\n   268→### Skill with Required Sources\n   269→\n   270→```yaml\n   271→---\n   272→name: \"Linear Triage\"\n   273→description: \"Triage and prioritize Linear issues\"\n   274→requiredSources:\n   275→  - linear\n   276→---\n   277→\n   278→# Linear Triage\n   279→\n   280→When triaging issues:\n   281→1. List unassigned issues from the current sprint\n   282→2. Categorize by severity\n   283→3. Suggest assignees based on expertise\n   284→```\n   285→\n   286→**Recommended icon**: Kanban board or list icon\n   287→\n   288→When this skill is invoked, the `linear` source is automatically enabled for the\n   289→session — no manual toggle needed.\n   290→\n   291→## Overriding SDK Skills\n   292→\n   293→To customize a built-in SDK skill like `/commit`:\n   294→\n   295→1. Create `~/.craft-agent/workspaces/{ws}/skills/commit/SKILL.md`\n   296→2. Write your custom instructions\n   297→3. Add an icon\n   298→4. Run `skill_validate({ skillSlug: \"commit\" })`\n   299→\n   300→Your skill will be used instead of the SDK's built-in version.\n   301→\n   302→This is useful for:\n   303→- Adding team-specific commit message formats\n   304→- Enforcing project-specific coding standards\n   305→- Customizing review criteria for your codebase\n   306→\n   307→## Best Practices\n   308→\n   309→1. **Be specific**: Give Claude clear, actionable instructions\n   310→2. **Include examples**: Show the expected output format\n   311→3. **Set boundaries**: Explain what NOT to do\n   312→4. **Keep focused**: One skill = one specific task or domain\n   313→5. **Add a relevant icon**: Makes skills easily identifiable in the UI\n   314→6. **Always validate**: Run `skill_validate` after creating or editing\n   315→\n   316→## Troubleshooting\n   317→\n   318→**Skill not loading:**\n   319→- Check slug format (lowercase, alphanumeric, hyphens only)\n   320→- Verify SKILL.md exists and is readable\n   321→- Run `skill_validate` for detailed errors\n   322→\n   323→**Skill not triggering:**\n   324→- Check glob patterns match your files\n   325→- Verify skill is in correct workspace\n   326→\n   327→**Icon not showing:**\n   328→- Use supported formats: svg, png, jpg, jpeg\n   329→- File must be named `icon.{ext}` (not `my-icon.svg`)\n   330→- Check icon file is not corrupted\n   331→- For SVG, ensure valid XML structure\n   332→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n","timestamp":1771300606697,"toolName":"Read","toolUseId":"toolu_01ER9vDNxfHVaNvfWsRjrYMQ","toolInput":{"file_path":"./Users/andresilvagomez/.craft-agent/docs/skills.md"},"toolResult":"     1→# Skills Configuration Guide\n     2→\n     3→This guide explains how to create and configure skills in Craft Agent.\n     4→\n     5→## What Are Skills?\n     6→\n     7→Skills are specialized instructions that extend Claude's capabilities for specific tasks. They use **the exact same SKILL.md format as the Claude Code SDK** - making skills fully compatible between systems.\n     8→\n     9→**Key points:**\n    10→- Skills are invoked via slash commands (e.g., `/commit`, `/review-pr`)\n    11→- Skills can be automatically triggered by file patterns (globs)\n    12→- Skills can pre-approve specific tools to run without prompting\n    13→- The SKILL.md format is identical to what Claude Code uses internally\n    14→\n    15→## Same Format as Claude Code SDK\n    16→\n    17→Craft Agent uses **the identical SKILL.md format** as the Claude Code SDK. This means:\n    18→\n    19→1. **Format compatibility**: Any skill written for Claude Code works in Craft Agent\n    20→2. **Same frontmatter fields**: `name`, `description`, `globs`, `alwaysAllow`, `requiredSources`\n    21→3. **Same content structure**: Markdown body with instructions for Claude\n    22→\n    23→**What Craft Agent adds:**\n    24→- **Visual icons**: Display custom icons in the UI for each skill\n    25→- **Workspace organization**: Skills are scoped to workspaces\n    26→- **UI management**: Browse, edit, and validate skills through the interface\n    27→\n    28→## Skill Precedence\n    29→\n    30→When a skill is invoked (e.g., `/commit`):\n    31→\n    32→1. **Workspace skill checked first** - If `~/.craft-agent/workspaces/{id}/skills/commit/SKILL.md` exists, it's used\n    33→2. **SDK skill as fallback** - If no workspace skill exists, the built-in SDK skill is used\n    34→\n    35→This allows you to:\n    36→- **Override SDK skills** - Create a workspace skill with the same slug to replace built-in behavior\n    37→- **Extend SDK skills** - Reference SDK behavior in your custom skill and add workspace-specific instructions\n    38→- **Create new skills** - Add entirely new skills not in the SDK\n    39→\n    40→## Skill Storage\n    41→\n    42→Skills are stored as folders:\n    43→```\n    44→~/.craft-agent/workspaces/{workspaceId}/skills/{slug}/\n    45→├── SKILL.md          # Required: Skill definition (same format as Claude Code SDK)\n    46→├── icon.svg          # Recommended: Skill icon for UI display\n    47→├── icon.png          # Alternative: PNG icon\n    48→└── (other files)     # Optional: Additional resources\n    49→```\n    50→\n    51→## SKILL.md Format\n    52→\n    53→The format is identical to Claude Code SDK skills:\n    54→\n    55→```yaml\n    56→---\n    57→name: \"Skill Display Name\"\n    58→description: \"Brief description shown in skill list\"\n    59→globs: [\"*.ts\", \"*.tsx\"]     # Optional: file patterns that trigger skill\n    60→alwaysAllow: [\"Bash\"]        # Optional: tools to always allow\n    61→requiredSources:             # Optional: sources to auto-enable on invocation\n    62→  - linear\n    63→---\n    64→\n    65→# Skill Instructions\n    66→\n    67→Your skill content goes here. This is injected into Claude's context\n    68→when the skill is active.\n    69→\n    70→## Guidelines\n    71→\n    72→- Specific instructions for Claude\n    73→- Best practices to follow\n    74→- Things to avoid\n    75→\n    76→## Examples\n    77→\n    78→Show Claude how to perform the task correctly.\n    79→```\n    80→\n    81→## Metadata Fields\n    82→\n    83→### name (required)\n    84→Display name for the skill. Shown in the UI and skill list.\n    85→\n    86→### description (required)\n    87→Brief description (1-2 sentences) explaining what the skill does.\n    88→\n    89→### globs (optional)\n    90→Array of glob patterns. When a file matching these patterns is being worked on,\n    91→the skill may be automatically suggested or activated.\n    92→\n    93→```yaml\n    94→globs:\n    95→  - \"*.test.ts\"           # Test files\n    96→  - \"*.spec.tsx\"          # React test files\n    97→  - \"**/__tests__/**\"     # Test directories\n    98→```\n    99→\n   100→### alwaysAllow (optional)\n   101→Array of tool names that are automatically allowed when this skill is active.\n   102→Useful for skills that require specific tools without prompting.\n   103→\n   104→```yaml\n   105→alwaysAllow:\n   106→  - \"Bash\"                # Allow bash commands\n   107→  - \"Write\"               # Allow file writes\n   108→```\n   109→\n   110→### requiredSources (optional)\n   111→Array of source slugs to auto-enable when this skill is invoked.\n   112→When a user mentions the skill, the listed sources are enabled for the session\n   113→before the agent starts — so tools from those sources are available from the first turn.\n   114→\n   115→Sources must exist in the workspace and be authenticated. Unauthenticated or\n   116→missing sources are silently skipped (the existing runtime auto-enable handles them\n   117→as a fallback).\n   118→\n   119→```yaml\n   120→requiredSources:\n   121→  - linear               # Auto-enable Linear source\n   122→  - github               # Auto-enable GitHub source\n   123→```\n   124→\n   125→## Creating a Skill\n   126→\n   127→### 1. Create the skill directory\n   128→\n   129→```bash\n   130→mkdir -p ~/.craft-agent/workspaces/{ws}/skills/my-skill\n   131→```\n   132→\n   133→### 2. Write SKILL.md\n   134→\n   135→```markdown\n   136→---\n   137→name: \"Code Review\"\n   138→description: \"Review code changes for quality, security, and best practices\"\n   139→globs: [\"*.ts\", \"*.tsx\", \"*.js\", \"*.jsx\"]\n   140→---\n   141→\n   142→# Code Review Skill\n   143→\n   144→When reviewing code, focus on:\n   145→\n   146→## Quality Checks\n   147→- Consistent code style\n   148→- Clear naming conventions\n   149→- Appropriate abstractions\n   150→\n   151→## Security Checks\n   152→- Input validation\n   153→- Authentication/authorization\n   154→- Sensitive data handling\n   155→\n   156→## Best Practices\n   157→- Error handling\n   158→- Performance considerations\n   159→- Test coverage\n   160→```\n   161→\n   162→### 3. Add an icon (IMPORTANT)\n   163→\n   164→Every skill should have a visually relevant icon. This helps users quickly identify skills in the UI.\n   165→\n   166→**Icon requirements:**\n   167→- **Filename**: Must be `icon.svg`, `icon.png`, `icon.jpg`, or `icon.jpeg`\n   168→- **Format**: SVG preferred (scalable, crisp at all sizes)\n   169→- **Size**: For PNG/JPG, use at least 64x64 pixels\n   170→\n   171→**How to get an icon:**\n   172→\n   173→1. **Search online icon libraries:**\n   174→   - [Heroicons](https://heroicons.com/) - MIT licensed\n   175→   - [Feather Icons](https://feathericons.com/) - MIT licensed\n   176→   - [Simple Icons](https://simpleicons.org/) - Brand icons (git, npm, etc.)\n   177→\n   178→2. **Use WebFetch to download:**\n   179→   ```\n   180→   # Find an appropriate icon URL and download it\n   181→   WebFetch to get SVG content, then save to icon.svg\n   182→   ```\n   183→\n   184→3. **Match the skill's purpose:**\n   185→   - Git/commit skill → git icon or commit icon\n   186→   - Test skill → checkmark or test tube icon\n   187→   - Deploy skill → rocket or cloud icon\n   188→   - Review skill → magnifying glass or eye icon\n   189→\n   190→### 4. Validate the skill\n   191→\n   192→**IMPORTANT**: Always validate after creating or editing a skill:\n   193→\n   194→```\n   195→skill_validate({ skillSlug: \"my-skill\" })\n   196→```\n   197→\n   198→This validates:\n   199→- Slug format (lowercase, alphanumeric, hyphens only)\n   200→- SKILL.md exists and is readable\n   201→- YAML frontmatter is valid\n   202→- Required fields present (name, description)\n   203→- Content is non-empty\n   204→- Icon format (if present)\n   205→\n   206→## Example Skills\n   207→\n   208→### Commit Message Skill\n   209→\n   210→```yaml\n   211→---\n   212→name: \"Commit\"\n   213→description: \"Create well-formatted git commit messages\"\n   214→alwaysAllow: [\"Bash\"]\n   215→---\n   216→\n   217→# Commit Message Guidelines\n   218→\n   219→When creating commits:\n   220→\n   221→1. **Format**: Use conventional commits\n   222→   - `feat:` New feature\n   223→   - `fix:` Bug fix\n   224→   - `docs:` Documentation\n   225→   - `refactor:` Code refactoring\n   226→   - `test:` Adding tests\n   227→\n   228→2. **Style**:\n   229→   - Keep subject line under 72 characters\n   230→   - Use imperative mood (\"Add feature\" not \"Added feature\")\n   231→   - Explain why, not what (the diff shows what)\n   232→\n   233→3. **Co-authorship**:\n   234→   Always include: `Co-Authored-By: Claude <noreply@anthropic.com>`\n   235→```\n   236→\n   237→**Recommended icon**: Git commit icon from Heroicons or Simple Icons\n   238→\n   239→### Team Standards Skill\n   240→\n   241→```yaml\n   242→---\n   243→name: \"Team Standards\"\n   244→description: \"Enforce team coding conventions and patterns\"\n   245→globs: [\"src/**/*.ts\", \"src/**/*.tsx\"]\n   246→---\n   247→\n   248→# Team Coding Standards\n   249→\n   250→## File Organization\n   251→- One component per file\n   252→- Co-locate tests with source files\n   253→- Use barrel exports (index.ts)\n   254→\n   255→## Naming Conventions\n   256→- Components: PascalCase\n   257→- Hooks: camelCase with `use` prefix\n   258→- Constants: SCREAMING_SNAKE_CASE\n   259→\n   260→## Import Order\n   261→1. External packages\n   262→2. Internal packages (@company/*)\n   263→3. Relative imports\n   264→```\n   265→\n   266→**Recommended icon**: Clipboard list or checklist icon\n   267→\n   268→### Skill with Required Sources\n   269→\n   270→```yaml\n   271→---\n   272→name: \"Linear Triage\"\n   273→description: \"Triage and prioritize Linear issues\"\n   274→requiredSources:\n   275→  - linear\n   276→---\n   277→\n   278→# Linear Triage\n   279→\n   280→When triaging issues:\n   281→1. List unassigned issues from the current sprint\n   282→2. Categorize by severity\n   283→3. Suggest assignees based on expertise\n   284→```\n   285→\n   286→**Recommended icon**: Kanban board or list icon\n   287→\n   288→When this skill is invoked, the `linear` source is automatically enabled for the\n   289→session — no manual toggle needed.\n   290→\n   291→## Overriding SDK Skills\n   292→\n   293→To customize a built-in SDK skill like `/commit`:\n   294→\n   295→1. Create `~/.craft-agent/workspaces/{ws}/skills/commit/SKILL.md`\n   296→2. Write your custom instructions\n   297→3. Add an icon\n   298→4. Run `skill_validate({ skillSlug: \"commit\" })`\n   299→\n   300→Your skill will be used instead of the SDK's built-in version.\n   301→\n   302→This is useful for:\n   303→- Adding team-specific commit message formats\n   304→- Enforcing project-specific coding standards\n   305→- Customizing review criteria for your codebase\n   306→\n   307→## Best Practices\n   308→\n   309→1. **Be specific**: Give Claude clear, actionable instructions\n   310→2. **Include examples**: Show the expected output format\n   311→3. **Set boundaries**: Explain what NOT to do\n   312→4. **Keep focused**: One skill = one specific task or domain\n   313→5. **Add a relevant icon**: Makes skills easily identifiable in the UI\n   314→6. **Always validate**: Run `skill_validate` after creating or editing\n   315→\n   316→## Troubleshooting\n   317→\n   318→**Skill not loading:**\n   319→- Check slug format (lowercase, alphanumeric, hyphens only)\n   320→- Verify SKILL.md exists and is readable\n   321→- Run `skill_validate` for detailed errors\n   322→\n   323→**Skill not triggering:**\n   324→- Check glob patterns match your files\n   325→- Verify skill is in correct workspace\n   326→\n   327→**Icon not showing:**\n   328→- Use supported formats: svg, png, jpg, jpeg\n   329→- File must be named `icon.{ext}` (not `my-icon.svg`)\n   330→- Check icon file is not corrupted\n   331→- For SVG, ensure valid XML structure\n   332→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n","toolStatus":"completed","toolIntent":"Understand the skill creation workflow and SKILL.md format","toolDisplayName":"Read Skills Docs","toolDisplayMeta":{"displayName":"Read","category":"native"},"isError":false,"turnId":"msg_01PWRn44f5dFXhVH6sjLnnZs"}
{"id":"msg-1771300608060-l85psl","type":"tool","content":"# Repository Structure\n\nBased on the GitHub page content, here's the repository structure for `ehmo/platform-design-skills`:\n\n## Files and Folders\n```\nskills/\n.gitignore\nAGENTS.md\nApple_HIG.pdf\nCLAUDE.md\nLICENSE\nREADME.md\n```\n\n## About the \"macos\" Skill\n\nThe repository **does not contain** a skill specifically called \"macos-design-guidelines.\" However, it includes a **\"macos\"** skill that serves this purpose.\n\n### macos Skill Description\n\nThe macOS skill covers \"menu bars, window management, toolbars, keyboard-driven interaction, and the expectations of desktop power users.\" It's recommended when building macOS applications with SwiftUI or AppKit, implementing menu systems, or designing native Mac interfaces.\n\n## Repository Purpose\n\nThis collection provides \"300+ actionable rules for iOS, iPadOS, macOS, watchOS, visionOS, tvOS, Android, and Web\" based on official design guidelines from Apple HIG, Material Design 3, and WCAG 2.2 standards.","timestamp":1771300608060,"toolName":"WebFetch","toolUseId":"toolu_01KqZPdUCRQZzf4zWwiecX4L","toolInput":{"url":"https://github.com/ehmo/platform-design-skills","prompt":"List all files and folders in this repository. I'm looking for a skill called \"macos-design-guidelines\". Show me the repository structure and any README content."},"toolResult":"# Repository Structure\n\nBased on the GitHub page content, here's the repository structure for `ehmo/platform-design-skills`:\n\n## Files and Folders\n```\nskills/\n.gitignore\nAGENTS.md\nApple_HIG.pdf\nCLAUDE.md\nLICENSE\nREADME.md\n```\n\n## About the \"macos\" Skill\n\nThe repository **does not contain** a skill specifically called \"macos-design-guidelines.\" However, it includes a **\"macos\"** skill that serves this purpose.\n\n### macos Skill Description\n\nThe macOS skill covers \"menu bars, window management, toolbars, keyboard-driven interaction, and the expectations of desktop power users.\" It's recommended when building macOS applications with SwiftUI or AppKit, implementing menu systems, or designing native Mac interfaces.\n\n## Repository Purpose\n\nThis collection provides \"300+ actionable rules for iOS, iPadOS, macOS, watchOS, visionOS, tvOS, Android, and Web\" based on official design guidelines from Apple HIG, Material Design 3, and WCAG 2.2 standards.","toolStatus":"completed","toolIntent":"Get the repository contents to find the macos-design-guidelines skill","toolDisplayName":"Fetch GitHub Repo","toolDisplayMeta":{"displayName":"Fetch URL","category":"native"},"isError":false,"turnId":"msg_01PWRn44f5dFXhVH6sjLnnZs"}
{"id":"msg-1771300618916-sumq8j","type":"tool","content":"# Folders in skills/ Directory\n\nBased on the webpage content, here are all the folders inside the **skills/** directory:\n\n1. android\n2. ios\n3. ipados\n4. macos\n5. tvos\n6. visionos\n7. watchos\n8. web\n\nThese eight subdirectories appear to represent design skills organized by different Apple and Android platforms.","timestamp":1771300618916,"toolName":"WebFetch","toolUseId":"toolu_01KPt47Tf7D5VDX7hrmEaxtt","toolInput":{"url":"https://github.com/ehmo/platform-design-skills/tree/main/skills","prompt":"List ALL folders/directories inside the skills/ directory. I need the exact folder names."},"toolResult":"# Folders in skills/ Directory\n\nBased on the webpage content, here are all the folders inside the **skills/** directory:\n\n1. android\n2. ios\n3. ipados\n4. macos\n5. tvos\n6. visionos\n7. watchos\n8. web\n\nThese eight subdirectories appear to represent design skills organized by different Apple and Android platforms.","toolStatus":"completed","toolIntent":"Find the exact skill folder name for the macOS design guidelines skill","toolDisplayName":"Fetch Skills Directory","toolDisplayMeta":{"displayName":"Fetch URL","category":"native"},"isError":false,"turnId":"msg_01UbiM8YXjkokNCXwqJ3CBb1"}
{"id":"msg-1771300626431-qp6okl","type":"tool","content":"# macOS Human Interface Guidelines\n\nMac apps serve power users who expect deep keyboard control, persistent menu bars, resizable multi-window layouts, and tight system integration. These guidelines codify Apple's HIG into actionable rules with SwiftUI and AppKit examples.\n\n---\n\n## 1. Menu Bar (CRITICAL)\n\nEvery Mac app must have a menu bar. It is the primary discovery mechanism for commands. Users who cannot find a feature will look in the menu bar before anywhere else.\n\n### Rule 1.1 — Provide Standard Menus\n\nEvery app must include at minimum: **App**, **File**, **Edit**, **View**, **Window**, **Help**. Omit File only if the app is not document-based. Add app-specific menus between Edit and View or between View and Window.\n\n```swift\n// SwiftUI — Standard menu structure\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        .commands {\n            // Adds to existing standard menus\n            CommandGroup(after: .newItem) {\n                Button(\"New from Template...\") { newFromTemplate() }\n                    .keyboardShortcut(\"T\", modifiers: [.command, .shift])\n            }\n            CommandMenu(\"Canvas\") {\n                Button(\"Zoom to Fit\") { zoomToFit() }\n                    .keyboardShortcut(\"0\", modifiers: .command)\n                Divider()\n                Button(\"Add Artboard\") { addArtboard() }\n                    .keyboardShortcut(\"A\", modifiers: [.command, .shift])\n            }\n        }\n    }\n}\n```\n\n```swift\n// AppKit — Building menus programmatically\nlet editMenu = NSMenu(title: \"Edit\")\nlet undoItem = NSMenuItem(title: \"Undo\", action: #selector(UndoManager.undo), keyEquivalent: \"z\")\nlet redoItem = NSMenuItem(title: \"Redo\", action: #selector(UndoManager.redo), keyEquivalent: \"Z\")\neditMenu.addItem(undoItem)\neditMenu.addItem(redoItem)\neditMenu.addItem(.separator())\n```\n\n### Rule 1.2 — Keyboard Shortcuts for All Menu Items\n\nEvery menu item that performs an action must have a keyboard shortcut. Use standard shortcuts for standard actions (Cmd+C, Cmd+V, Cmd+Z, etc.). Custom shortcuts should use Cmd plus a letter. Reserve Cmd+Shift, Cmd+Option, and Cmd+Ctrl combos for secondary actions.\n\n**Standard Shortcut Reference:**\n\n| Action | Shortcut |\n|--------|----------|\n| New | Cmd+N |\n| Open | Cmd+O |\n| Close | Cmd+W |\n| Save | Cmd+S |\n| Save As | Cmd+Shift+S |\n| Print | Cmd+P |\n| Undo | Cmd+Z |\n| Redo | Cmd+Shift+Z |\n| Cut | Cmd+X |\n| Copy | Cmd+C |\n| Paste | Cmd+V |\n| Select All | Cmd+A |\n| Find | Cmd+F |\n| Find Next | Cmd+G |\n| Preferences/Settings | Cmd+, |\n| Hide App | Cmd+H |\n| Quit | Cmd+Q |\n| Minimize | Cmd+M |\n| Fullscreen | Cmd+Ctrl+F |\n\n### Rule 1.3 — Dynamic Menu Updates\n\nMenu items must reflect current state. Disable items that are not applicable. Update titles to match context (e.g., \"Undo Typing\" not just \"Undo\"). Toggle checkmarks for on/off states.\n\n```swift\n// SwiftUI — Dynamic menu state\nCommandGroup(replacing: .toolbar) {\n    Button(showingSidebar ? \"Hide Sidebar\" : \"Show Sidebar\") {\n        showingSidebar.toggle()\n    }\n    .keyboardShortcut(\"S\", modifiers: [.command, .control])\n}\n```\n\n```swift\n// AppKit — Validate menu items\noverride func validateMenuItem(_ menuItem: NSMenuItem) -> Bool {\n    if menuItem.action == #selector(delete(_:)) {\n        menuItem.title = selectedItems.count > 1 ? \"Delete \\(selectedItems.count) Items\" : \"Delete\"\n        return !selectedItems.isEmpty\n    }\n    return super.validateMenuItem(menuItem)\n}\n```\n\n### Rule 1.4 — Contextual Menus\n\nProvide right-click context menus on all interactive elements. Context menus should contain the most relevant subset of menu bar actions for the clicked element, plus element-specific actions.\n\n```swift\n// SwiftUI\nText(item.name)\n    .contextMenu {\n        Button(\"Rename...\") { rename(item) }\n        Button(\"Duplicate\") { duplicate(item) }\n        Divider()\n        Button(\"Delete\", role: .destructive) { delete(item) }\n    }\n```\n\n### Rule 1.5 — App Menu Structure\n\nThe App menu (leftmost, bold app name) must contain: About, Preferences/Settings (Cmd+,), Services submenu, Hide App (Cmd+H), Hide Others (Cmd+Option+H), Show All, Quit (Cmd+Q). Never rename or remove these standard items.\n\n```swift\n// SwiftUI — Settings scene\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup { ContentView() }\n        Settings { SettingsView() }  // Automatically wired to Cmd+,\n    }\n}\n```\n\n---\n\n## 2. Windows (CRITICAL)\n\nMac users expect full control over window size, position, and lifecycle. An app that fights window management feels fundamentally broken on the Mac.\n\n### Rule 2.1 — Resizable with Sensible Minimums\n\nAll main windows must be freely resizable. Set a minimum size that keeps the UI usable. Never set a maximum size unless the content truly cannot scale (rare).\n\n```swift\n// SwiftUI\nWindowGroup {\n    ContentView()\n        .frame(minWidth: 600, minHeight: 400)\n}\n.defaultSize(width: 900, height: 600)\n```\n\n```swift\n// AppKit\nwindow.minSize = NSSize(width: 600, height: 400)\nwindow.setContentSize(NSSize(width: 900, height: 600))\n```\n\n### Rule 2.2 — Support Fullscreen and Split View\n\nOpt into native fullscreen by setting the appropriate window collection behavior. The green traffic-light button must either enter fullscreen or show the tile picker.\n\n```swift\n// AppKit\nwindow.collectionBehavior.insert(.fullScreenPrimary)\n```\n\nSwiftUI windows get fullscreen support automatically.\n\n### Rule 2.3 — Multiple Windows\n\nUnless your app is a single-purpose utility, support multiple windows. Document-based apps must allow multiple documents open simultaneously. Use `WindowGroup` or `DocumentGroup` in SwiftUI.\n\n```swift\n// SwiftUI — Document-based app\n@main\nstruct TextEditorApp: App {\n    var body: some Scene {\n        DocumentGroup(newDocument: TextDocument()) { file in\n            TextEditorView(document: file.$document)\n        }\n    }\n}\n```\n\n### Rule 2.4 — Title Bar Shows Document Info\n\nFor document-based apps, the title bar must show the document name. Support proxy icon dragging. Show edited state (dot in close button). Support title bar renaming on click.\n\n```swift\n// AppKit\nwindow.representedURL = document.fileURL\nwindow.title = document.displayName\nwindow.isDocumentEdited = document.hasUnsavedChanges\n```\n\n```swift\n// SwiftUI — NavigationSplitView titles\nNavigationSplitView {\n    SidebarView()\n} detail: {\n    DetailView()\n        .navigationTitle(document.name)\n}\n```\n\n### Rule 2.5 — Remember Window State\n\nPersist window position, size, and state across launches. Use `NSWindow.setFrameAutosaveName` or SwiftUI's built-in state restoration.\n\n```swift\n// AppKit\nwindow.setFrameAutosaveName(\"MainWindow\")\n\n// SwiftUI — Automatic with WindowGroup\nWindowGroup(id: \"main\") {\n    ContentView()\n}\n.defaultPosition(.center)\n```\n\n### Rule 2.6 — Traffic Light Buttons\n\nNever hide or reposition the close (red), minimize (yellow), or zoom (green) buttons. They must remain in the top-left corner. If using a custom title bar, the buttons must still be visible and functional.\n\n```swift\n// AppKit — Custom title bar that preserves traffic lights\nwindow.titlebarAppearsTransparent = true\nwindow.styleMask.insert(.fullSizeContentView)\n// Traffic lights remain functional and visible\n```\n\n---\n\n## 3. Toolbars (HIGH)\n\nToolbars are the secondary command surface after the menu bar. They provide quick access to frequent actions and should be customizable.\n\n### Rule 3.1 — Unified Title Bar and Toolbar\n\nUse the unified title bar + toolbar style for a modern appearance. The toolbar sits in the title bar area, saving vertical space.\n\n```swift\n// SwiftUI\nWindowGroup {\n    ContentView()\n        .toolbar {\n            ToolbarItem(placement: .primaryAction) {\n                Button(action: compose) {\n                    Label(\"Compose\", systemImage: \"square.and.pencil\")\n                }\n            }\n        }\n}\n.windowToolbarStyle(.unified)\n```\n\n```swift\n// AppKit\nwindow.titleVisibility = .hidden\nwindow.toolbarStyle = .unified\n```\n\n### Rule 3.2 — User-Customizable Toolbars\n\nAllow users to add, remove, and rearrange toolbar items. Provide a default set and a superset of available items.\n\n```swift\n// SwiftUI — Customizable toolbar\n.toolbar(id: \"main\") {\n    ToolbarItem(id: \"compose\", placement: .primaryAction) {\n        Button(action: compose) {\n            Label(\"Compose\", systemImage: \"square.and.pencil\")\n        }\n    }\n    ToolbarItem(id: \"filter\", placement: .secondaryAction) {\n        Button(action: toggleFilter) {\n            Label(\"Filter\", systemImage: \"line.3.horizontal.decrease\")\n        }\n    }\n}\n.toolbarRole(.editor)\n```\n\n### Rule 3.3 — Segmented Controls for View Switching\n\nUse a segmented control or picker in the toolbar for switching between content views (e.g., List/Grid/Column). This is a toolbar pattern, not a tab bar.\n\n```swift\n// SwiftUI\nToolbarItem(placement: .principal) {\n    Picker(\"View Mode\", selection: $viewMode) {\n        Label(\"List\", systemImage: \"list.bullet\").tag(ViewMode.list)\n        Label(\"Grid\", systemImage: \"square.grid.2x2\").tag(ViewMode.grid)\n        Label(\"Column\", systemImage: \"rectangle.split.3x1\").tag(ViewMode.column)\n    }\n    .pickerStyle(.segmented)\n}\n```\n\n### Rule 3.4 — Search Field in Toolbar\n\nPlace the search field in the trailing area of the toolbar. Use `.searchable()` in SwiftUI for standard search behavior with suggestions and tokens.\n\n```swift\n// SwiftUI\nNavigationSplitView {\n    SidebarView()\n} detail: {\n    ContentListView()\n        .searchable(text: $searchText, placement: .toolbar, prompt: \"Search items\")\n        .searchSuggestions {\n            ForEach(suggestions) { suggestion in\n                Text(suggestion.title).searchCompletion(suggestion.title)\n            }\n        }\n}\n```\n\n### Rule 3.5 — Toolbar Labels and Icons\n\nToolbar items should have both an icon (SF Symbol) and a text label. In compact mode, show icons only. Prefer labeled icons for discoverability. Use `Label` to supply both.\n\n---\n\n## 4. Sidebars (HIGH)\n\nSidebars are the primary navigation surface for Mac apps. They appear on the leading edge and provide persistent access to top-level sections and content libraries.\n\n### Rule 4.1 — Leading Edge, Collapsible\n\nPlace the sidebar on the left (leading) edge. Make it collapsible via the toolbar button or Cmd+Ctrl+S. Persist collapsed state.\n\n```swift\n// SwiftUI\nNavigationSplitView(columnVisibility: $columnVisibility) {\n    List(selection: $selection) {\n        Section(\"Library\") {\n            Label(\"All Items\", systemImage: \"tray.full\")\n            Label(\"Favorites\", systemImage: \"star\")\n            Label(\"Recent\", systemImage: \"clock\")\n        }\n        Section(\"Tags\") {\n            ForEach(tags) { tag in\n                Label(tag.name, systemImage: \"tag\")\n            }\n        }\n    }\n    .navigationSplitViewColumnWidth(min: 180, ideal: 220, max: 320)\n} detail: {\n    DetailView(selection: selection)\n}\n.navigationSplitViewStyle(.prominentDetail)\n```\n\n### Rule 4.2 — Source List Style\n\nUse the source list style (`.listStyle(.sidebar)`) for content-library navigation. Source lists have a translucent background that shows the desktop or window behind them with vibrancy effects.\n\n```swift\n// SwiftUI\nList(selection: $selection) {\n    ForEach(sections) { section in\n        Section(section.name) {\n            ForEach(section.items) { item in\n                NavigationLink(value: item) {\n                    Label(item.name, systemImage: item.icon)\n                }\n            }\n        }\n    }\n}\n.listStyle(.sidebar)\n```\n\n### Rule 4.3 — Outline Views for Hierarchies\n\nWhen content is hierarchical (e.g., folder trees, project structures), use disclosure groups or outline views to let users expand and collapse levels.\n\n```swift\n// SwiftUI — Recursive outline\nList(selection: $selection) {\n    OutlineGroup(rootNodes, children: \\.children) { node in\n        Label(node.name, systemImage: node.icon)\n    }\n}\n```\n\n### Rule 4.4 — Drag to Reorder\n\nSidebar items that can be reordered (bookmarks, favorites, custom sections) must support drag-to-reorder. Implement `onMove` or `NSOutlineView` drag delegates.\n\n```swift\n// SwiftUI\nForEach(favorites) { item in\n    Label(item.name, systemImage: item.icon)\n}\n.onMove { source, destination in\n    favorites.move(fromOffsets: source, toOffset: destination)\n}\n```\n\n### Rule 4.5 — Badge Counts\n\nShow badge counts on sidebar items for unread counts, pending items, or notifications. Use the `.badge()` modifier.\n\n```swift\n// SwiftUI\nLabel(\"Inbox\", systemImage: \"tray\")\n    .badge(unreadCount)\n```\n\n---\n\n## 5. Keyboard (CRITICAL)\n\nMac users rely on keyboard shortcuts more than any other platform. An app without comprehensive keyboard support is a broken Mac app.\n\n### Rule 5.1 — Cmd Shortcuts for Everything\n\nEvery action reachable by mouse must have a keyboard equivalent. Primary actions use Cmd+letter. Secondary actions use Cmd+Shift or Cmd+Option. Tertiary actions use Cmd+Ctrl.\n\n**Keyboard Shortcut Conventions:**\n\n| Modifier Pattern | Usage |\n|-----------------|-------|\n| Cmd+letter | Primary actions (New, Open, Save, etc.) |\n| Cmd+Shift+letter | Variant of primary (Save As, Find Previous) |\n| Cmd+Option+letter | Alternative mode (Paste and Match Style) |\n| Cmd+Ctrl+letter | Window/view controls (Fullscreen, Sidebar) |\n| Ctrl+letter | Emacs-style text navigation (acceptable) |\n| Fn+key | System functions (F11 Show Desktop, etc.) |\n\n### Rule 5.2 — Full Keyboard Navigation\n\nSupport Tab to move between controls. Support arrow keys within lists, grids, and tables. Support Shift+Tab for reverse navigation. Use `focusable()` and `@FocusState` in SwiftUI.\n\n```swift\n// SwiftUI — Focus management\nstruct ContentView: View {\n    @FocusState private var focusedField: Field?\n\n    var body: some View {\n        VStack {\n            TextField(\"Name\", text: $name)\n                .focused($focusedField, equals: .name)\n            TextField(\"Email\", text: $email)\n                .focused($focusedField, equals: .email)\n        }\n        .onSubmit { advanceFocus() }\n    }\n}\n```\n\n### Rule 5.3 — Escape to Cancel or Close\n\nEsc must dismiss popovers, sheets, dialogs, and cancel in-progress operations. In text fields, Esc reverts to the previous value. In modal dialogs, Esc is equivalent to clicking Cancel.\n\n```swift\n// SwiftUI — Sheet with Esc support (automatic)\n.sheet(isPresented: $showingSheet) {\n    SheetView()  // Esc dismisses automatically\n}\n\n// AppKit — Custom responder\noverride func cancelOperation(_ sender: Any?) {\n    dismiss(nil)\n}\n```\n\n### Rule 5.4 — Return for Default Action\n\nIn dialogs and forms, Return/Enter activates the default button (visually emphasized in blue). The default button is always the safest primary action.\n\n```swift\n// SwiftUI\nButton(\"Save\") { save() }\n    .keyboardShortcut(.defaultAction)  // Enter key\n\nButton(\"Cancel\") { cancel() }\n    .keyboardShortcut(.cancelAction)   // Esc key\n```\n\n### Rule 5.5 — Delete for Removal\n\nThe Delete key (Backspace) must remove selected items in lists, tables, and collections. Cmd+Delete for more destructive removal (move to Trash). Always support Cmd+Z to undo deletion.\n\n### Rule 5.6 — Space for Quick Look\n\nWhen items support previewing, Space bar should invoke Quick Look. Use the `QLPreviewPanel` API in AppKit or `.quickLookPreview()` in SwiftUI.\n\n```swift\n// SwiftUI\nList(selection: $selection) {\n    ForEach(files) { file in\n        FileRow(file: file)\n    }\n}\n.quickLookPreview($quickLookItem, in: files)\n```\n\n### Rule 5.7 — Arrow Key Navigation\n\nIn lists and grids, Up/Down arrow keys move selection. Left/Right collapse/expand disclosure groups or navigate columns. Cmd+Up goes to the beginning, Cmd+Down goes to the end.\n\n---\n\n## 6. Pointer and Mouse (HIGH)\n\nMac is a pointer-driven platform. Every interactive element must respond to hover, click, right-click, and drag.\n\n### Rule 6.1 — Hover States\n\nAll interactive elements must have a visible hover state. Buttons highlight, rows show a selection indicator, links change cursor. Use `.onHover` in SwiftUI.\n\n```swift\n// SwiftUI — Hover effect\nstruct HoverableRow: View {\n    @State private var isHovered = false\n\n    var body: some View {\n        HStack {\n            Text(item.name)\n            Spacer()\n            if isHovered {\n                Button(\"Edit\") { edit() }\n                    .buttonStyle(.borderless)\n            }\n        }\n        .padding(8)\n        .background(isHovered ? Color.primary.opacity(0.05) : .clear)\n        .cornerRadius(6)\n        .onHover { hovering in isHovered = hovering }\n    }\n}\n```\n\n### Rule 6.2 — Right-Click Context Menus\n\nEvery interactive element must respond to right-click with a contextual menu. The context menu should contain the most relevant actions for the clicked item.\n\n### Rule 6.3 — Drag and Drop\n\nSupport drag and drop for content manipulation: reordering items, moving between containers, importing files from Finder, and exporting content.\n\n```swift\n// SwiftUI — Drag and drop\nForEach(items) { item in\n    ItemView(item: item)\n        .draggable(item)\n}\n.dropDestination(for: Item.self) { items, location in\n    handleDrop(items, at: location)\n    return true\n}\n```\n\n```swift\n// Accepting file drops from Finder\n.dropDestination(for: URL.self) { urls, location in\n    importFiles(urls)\n    return true\n}\n```\n\n### Rule 6.4 — Scroll Behavior\n\nSupport both trackpad (smooth/inertial) and mouse wheel (discrete) scrolling. Use elastic/bounce scrolling at content boundaries. Support horizontal scrolling where appropriate.\n\n### Rule 6.5 — Cursor Changes\n\nChange the cursor to indicate affordances: pointer for clickable elements, I-beam for text, crosshair for drawing, resize handles at window/splitter edges, grab hand for draggable content.\n\n```swift\n// AppKit — Custom cursor\noverride func resetCursorRects() {\n    addCursorRect(bounds, cursor: .crosshair)\n}\n```\n\n### Rule 6.6 — Multi-Selection\n\nSupport Cmd+Click for non-contiguous selection and Shift+Click for range selection in lists, tables, and grids. This is a deeply ingrained Mac interaction pattern.\n\n```swift\n// SwiftUI — Tables with multi-selection\nTable(items, selection: $selectedItems) {\n    TableColumn(\"Name\", value: \\.name)\n    TableColumn(\"Date\", value: \\.dateFormatted)\n    TableColumn(\"Size\", value: \\.sizeFormatted)\n}\n```\n\n---\n\n## 7. Notifications and Alerts (MEDIUM)\n\nMac users are protective of their attention. Only interrupt when truly necessary.\n\n### Rule 7.1 — Use Notification Center Appropriately\n\nSend notifications only for events that happen outside the app or require user action. Never notify for routine operations. Notifications must be actionable.\n\n```swift\n// UserNotifications\nlet content = UNMutableNotificationContent()\ncontent.title = \"Download Complete\"\ncontent.body = \"project-assets.zip is ready\"\ncontent.categoryIdentifier = \"DOWNLOAD\"\ncontent.sound = .default\n\nlet request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: nil)\nUNUserNotificationCenter.current().add(request)\n```\n\n### Rule 7.2 — Alerts with Suppression Option\n\nFor recurring alerts, provide a \"Do not show this again\" checkbox. Respect the user's choice and persist it.\n\n```swift\n// AppKit — Alert with suppression\nlet alert = NSAlert()\nalert.messageText = \"Remove from library?\"\nalert.informativeText = \"The file will be moved to the Trash.\"\nalert.alertStyle = .warning\nalert.addButton(withTitle: \"Remove\")\nalert.addButton(withTitle: \"Cancel\")\nalert.showsSuppressionButton = true\nalert.suppressionButton?.title = \"Do not ask again\"\n\nlet response = alert.runModal()\nif alert.suppressionButton?.state == .on {\n    UserDefaults.standard.set(true, forKey: \"suppressRemoveAlert\")\n}\n```\n\n### Rule 7.3 — Don't Interrupt Unnecessarily\n\nNever show alerts for successful operations. Use inline status indicators, toolbar badges, or subtle animations instead. Reserve modal alerts for destructive or irreversible actions.\n\n### Rule 7.4 — Dock Badge\n\nShow a badge on the Dock icon for notification counts. Clear it promptly when the user addresses the notifications.\n\n```swift\n// AppKit\nNSApp.dockTile.badgeLabel = unreadCount > 0 ? \"\\(unreadCount)\" : nil\n```\n\n---\n\n## 8. System Integration (MEDIUM)\n\nMac apps exist in a rich ecosystem. Deep integration makes an app feel native.\n\n### Rule 8.1 — Dock Icon and Menus\n\nProvide a high-quality 1024x1024 app icon. Support Dock right-click menus for quick actions. Show recent documents in the Dock menu.\n\n```swift\n// AppKit — Dock menu\noverride func applicationDockMenu(_ sender: NSApplication) -> NSMenu? {\n    let menu = NSMenu()\n    menu.addItem(withTitle: \"New Window\", action: #selector(newWindow(_:)), keyEquivalent: \"\")\n    menu.addItem(withTitle: \"New Document\", action: #selector(newDocument(_:)), keyEquivalent: \"\")\n    menu.addItem(.separator())\n    for doc in recentDocuments.prefix(5) {\n        menu.addItem(withTitle: doc.name, action: #selector(openRecent(_:)), keyEquivalent: \"\")\n    }\n    return menu\n}\n```\n\n### Rule 8.2 — Spotlight Integration\n\nIndex app content for Spotlight search using `CSSearchableItem` and Core Spotlight. Users expect to find app content via Cmd+Space.\n\n```swift\nimport CoreSpotlight\n\nlet attributeSet = CSSearchableItemAttributeSet(contentType: .text)\nattributeSet.title = document.title\nattributeSet.contentDescription = document.summary\nattributeSet.thumbnailData = document.thumbnail?.pngData()\n\nlet item = CSSearchableItem(uniqueIdentifier: document.id, domainIdentifier: \"documents\", attributeSet: attributeSet)\nCSSearchableIndex.default().indexSearchableItems([item])\n```\n\n### Rule 8.3 — Quick Look Support\n\nProvide Quick Look previews for custom file types via a Quick Look Preview Extension. Users expect Space to preview any file in Finder.\n\n### Rule 8.4 — Share Extensions\n\nImplement the Share menu so users can share content from your app to Messages, Mail, Notes, etc. Also accept shared content from other apps.\n\n```swift\n// SwiftUI\nShareLink(item: document.url) {\n    Label(\"Share\", systemImage: \"square.and.arrow.up\")\n}\n```\n\n### Rule 8.5 — Services Menu\n\nRegister for the Services menu to receive text, URLs, or files from other apps. This is a uniquely Mac integration point that power users rely on.\n\n### Rule 8.6 — Shortcuts and AppleScript\n\nSupport the Shortcuts app by providing App Intents. For advanced automation, add AppleScript/JXA scripting support via an `.sdef` scripting dictionary.\n\n```swift\n// App Intents for Shortcuts\nstruct CreateDocumentIntent: AppIntent {\n    static var title: LocalizedStringResource = \"Create Document\"\n    static var description = IntentDescription(\"Creates a new document with the given title.\")\n\n    @Parameter(title: \"Title\")\n    var title: String\n\n    func perform() async throws -> some IntentResult {\n        let doc = DocumentManager.shared.create(title: title)\n        return .result(value: doc.title)\n    }\n}\n```\n\n---\n\n## 9. Visual Design (HIGH)\n\nMac apps should look and feel like they belong on the platform. Use system-provided materials, fonts, and colors.\n\n### Rule 9.1 — Use System Fonts\n\nUse SF Pro (the system font) at standard dynamic type sizes. Use SF Mono for code. Never hardcode font sizes; use semantic styles.\n\n```swift\n// SwiftUI — Semantic font styles\nText(\"Title\").font(.title)\nText(\"Headline\").font(.headline)\nText(\"Body text\").font(.body)\nText(\"Caption\").font(.caption)\nText(\"let x = 42\").font(.system(.body, design: .monospaced))\n```\n\n### Rule 9.2 — Vibrancy and Materials\n\nUse system materials for sidebar and toolbar backgrounds. Vibrancy lets the desktop or underlying content show through, anchoring the app to the Mac visual language.\n\n```swift\n// SwiftUI\nList { ... }\n    .listStyle(.sidebar)  // Automatic vibrancy\n\n// Custom vibrancy\nZStack {\n    VisualEffectView(material: .sidebar, blendingMode: .behindWindow)\n    Text(\"Sidebar Content\")\n}\n```\n\n```swift\n// AppKit — Visual effect view\nlet visualEffect = NSVisualEffectView()\nvisualEffect.material = .sidebar\nvisualEffect.blendingMode = .behindWindow\nvisualEffect.state = .followsWindowActiveState\n```\n\n### Rule 9.3 — Respect System Accent Color\n\nUse the system accent color for selection, emphasis, and interactive elements. Never override it with a fixed brand color for standard controls. Use `.accentColor` or `.tint` only on custom views when appropriate.\n\n```swift\n// SwiftUI — Follows system accent automatically\nButton(\"Action\") { doSomething() }\n    .buttonStyle(.borderedProminent)  // Uses system accent color\n\nToggle(\"Enable feature\", isOn: $isEnabled)  // Toggle tint follows accent\n```\n\n### Rule 9.4 — Support Dark Mode\n\nEvery view must support both Light and Dark appearances. Use semantic colors (`Color.primary`, `Color.secondary`, `.background`) rather than hardcoded colors. Test in both modes.\n\n```swift\n// SwiftUI — Semantic colors\nText(\"Title\").foregroundStyle(.primary)\nText(\"Subtitle\").foregroundStyle(.secondary)\n\nRoundedRectangle(cornerRadius: 8)\n    .fill(Color(nsColor: .controlBackgroundColor))\n\n// Asset catalog: define colors for Both Appearances\n// Never use Color.white or Color.black for UI surfaces\n```\n\n### Rule 9.5 — Translucency\n\nRespect the \"Reduce transparency\" accessibility setting. When transparency is reduced, replace translucent materials with solid backgrounds.\n\n```swift\n// SwiftUI\n@Environment(\\.accessibilityReduceTransparency) var reduceTransparency\n\nvar body: some View {\n    if reduceTransparency {\n        Color(nsColor: .windowBackgroundColor)\n    } else {\n        VisualEffectView(material: .sidebar, blendingMode: .behindWindow)\n    }\n}\n```\n\n### Rule 9.6 — Consistent Spacing and Layout\n\nUse 20pt standard margins, 8pt spacing between related controls, 20pt spacing between groups. Align controls to a grid. Use SwiftUI's built-in spacing or AppKit's Auto Layout with system spacing constraints.\n\n---\n\n## Keyboard Shortcut Quick Reference\n\n### Navigation\n| Shortcut | Action |\n|----------|--------|\n| Cmd+N | New window/document |\n| Cmd+O | Open |\n| Cmd+W | Close window/tab |\n| Cmd+Q | Quit app |\n| Cmd+, | Settings/Preferences |\n| Cmd+Tab | Switch apps |\n| Cmd+` | Switch windows within app |\n| Cmd+T | New tab |\n\n### Editing\n| Shortcut | Action |\n|----------|--------|\n| Cmd+Z | Undo |\n| Cmd+Shift+Z | Redo |\n| Cmd+X / C / V | Cut / Copy / Paste |\n| Cmd+A | Select All |\n| Cmd+D | Duplicate |\n| Cmd+F | Find |\n| Cmd+G | Find Next |\n| Cmd+Shift+G | Find Previous |\n| Cmd+E | Use Selection for Find |\n\n### View\n| Shortcut | Action |\n|----------|--------|\n| Cmd+Ctrl+F | Toggle fullscreen |\n| Cmd+Ctrl+S | Toggle sidebar |\n| Cmd+0 | Show/hide toolbar |\n| Cmd++ / Cmd+- | Zoom in/out |\n| Cmd+0 | Actual size |\n\n---\n\n## Evaluation Checklist\n\nBefore shipping a Mac app, verify:\n\n### Menu Bar\n- [ ] App has a complete menu bar with standard menus\n- [ ] All actions have keyboard shortcuts\n- [ ] Menu items dynamically update (enable/disable, title changes)\n- [ ] Context menus on all interactive elements\n- [ ] App menu has About, Settings, Hide, Quit\n\n### Windows\n- [ ] Windows are freely resizable with sensible minimums\n- [ ] Fullscreen and Split View work\n- [ ] Multiple windows supported (if appropriate)\n- [ ] Window position and size persist across launches\n- [ ] Traffic light buttons visible and functional\n- [ ] Document title and edited state shown (if document-based)\n\n### Toolbars\n- [ ] Toolbar present with common actions\n- [ ] Toolbar is user-customizable\n- [ ] Search field available in toolbar\n\n### Sidebars\n- [ ] Sidebar for navigation (if app has multiple sections)\n- [ ] Sidebar is collapsible\n- [ ] Source list style with vibrancy\n\n### Keyboard\n- [ ] Full keyboard navigation (Tab, arrows, Enter, Esc)\n- [ ] Cmd+Z undo for all destructive actions\n- [ ] Space for Quick Look previews\n- [ ] Delete key removes selected items\n- [ ] No keyboard traps (user can always Tab out)\n\n### Pointer\n- [ ] Hover states on interactive elements\n- [ ] Right-click context menus everywhere\n- [ ] Drag and drop for content manipulation\n- [ ] Cmd+Click for multi-selection\n- [ ] Appropriate cursor changes\n\n### Notifications\n- [ ] Notifications only for important events\n- [ ] Alerts have suppression option for recurring ones\n- [ ] No modal alerts for routine operations\n\n### System Integration\n- [ ] High-quality Dock icon\n- [ ] Content indexed in Spotlight (if applicable)\n- [ ] Share menu works\n- [ ] App Intents for Shortcuts\n\n### Visual Design\n- [ ] System fonts at semantic sizes\n- [ ] Dark Mode fully supported\n- [ ] System accent color respected\n- [ ] Translucency respects accessibility setting\n- [ ] Consistent spacing on 8pt grid\n\n---\n\n## Anti-Patterns\n\n**Do not do these things in a Mac app:**\n\n1. **No menu bar** — Every Mac app needs a menu bar. Period. A Mac app without menus is like a car without a steering wheel.\n\n2. **Hamburger menus** — Never use a hamburger menu on Mac. The menu bar exists for this purpose. Hamburger menus signal a lazy iOS port.\n\n3. **Tab bars at the bottom** — Mac apps use sidebars and toolbars, not iOS-style tab bars. If you need tabs, use actual document tabs in the tab bar (like Safari or Finder).\n\n4. **Large touch-sized targets** — Mac controls should be compact (22-28pt height). Users have precise pointer input. Giant buttons waste space and look out of place.\n\n5. **Floating action buttons** — FABs are a Material Design pattern. On Mac, place primary actions in the toolbar, menu bar, or as inline buttons.\n\n6. **Sheet for every action** — Don't use modal sheets for simple operations. Use popovers, inline editing, or direct manipulation. Sheets should be reserved for multi-step workflows or important decisions.\n\n7. **Custom window chrome** — Don't replace the standard title bar, traffic lights, or window controls with custom implementations. Users expect these to work consistently across all apps.\n\n8. **Ignoring keyboard** — If a power user must reach for the mouse to perform common actions, your keyboard support is insufficient.\n\n9. **Single-window only** — Unless your app is genuinely single-purpose (calculator, timer), support multiple windows. Users expect to Cmd+N for new windows.\n\n10. **Fixed window size** — Non-resizable windows feel broken on Mac. Users have displays ranging from 13\" laptops to 32\" externals and expect to use that space.\n\n11. **No Cmd+Z undo** — Every destructive or modifying action must be undoable. Users build muscle memory around Cmd+Z as their safety net.\n\n12. **Notification spam** — Mac apps that send excessive notifications get their permissions revoked. Only notify for events that genuinely need attention.\n\n13. **Ignoring Dark Mode** — A Mac app that looks wrong in Dark Mode appears abandoned. Always test both appearances.\n\n14. **Hardcoded colors** — Use semantic system colors, not hardcoded hex values. Your colors should adapt to Light/Dark mode and accessibility settings automatically.\n\n15. **No drag and drop** — Mac is a drag-and-drop platform. If users can see content, they expect to drag it somewhere.","timestamp":1771300626431,"toolName":"WebFetch","toolUseId":"toolu_01AKizvnNr7vMtQNmW32tGVm","toolInput":{"url":"https://raw.githubusercontent.com/ehmo/platform-design-skills/main/skills/macos/SKILL.md","prompt":"Return the COMPLETE content of this file exactly as-is. Do not summarize or truncate. Include every line."},"toolResult":"# macOS Human Interface Guidelines\n\nMac apps serve power users who expect deep keyboard control, persistent menu bars, resizable multi-window layouts, and tight system integration. These guidelines codify Apple's HIG into actionable rules with SwiftUI and AppKit examples.\n\n---\n\n## 1. Menu Bar (CRITICAL)\n\nEvery Mac app must have a menu bar. It is the primary discovery mechanism for commands. Users who cannot find a feature will look in the menu bar before anywhere else.\n\n### Rule 1.1 — Provide Standard Menus\n\nEvery app must include at minimum: **App**, **File**, **Edit**, **View**, **Window**, **Help**. Omit File only if the app is not document-based. Add app-specific menus between Edit and View or between View and Window.\n\n```swift\n// SwiftUI — Standard menu structure\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n        .commands {\n            // Adds to existing standard menus\n            CommandGroup(after: .newItem) {\n                Button(\"New from Template...\") { newFromTemplate() }\n                    .keyboardShortcut(\"T\", modifiers: [.command, .shift])\n            }\n            CommandMenu(\"Canvas\") {\n                Button(\"Zoom to Fit\") { zoomToFit() }\n                    .keyboardShortcut(\"0\", modifiers: .command)\n                Divider()\n                Button(\"Add Artboard\") { addArtboard() }\n                    .keyboardShortcut(\"A\", modifiers: [.command, .shift])\n            }\n        }\n    }\n}\n```\n\n```swift\n// AppKit — Building menus programmatically\nlet editMenu = NSMenu(title: \"Edit\")\nlet undoItem = NSMenuItem(title: \"Undo\", action: #selector(UndoManager.undo), keyEquivalent: \"z\")\nlet redoItem = NSMenuItem(title: \"Redo\", action: #selector(UndoManager.redo), keyEquivalent: \"Z\")\neditMenu.addItem(undoItem)\neditMenu.addItem(redoItem)\neditMenu.addItem(.separator())\n```\n\n### Rule 1.2 — Keyboard Shortcuts for All Menu Items\n\nEvery menu item that performs an action must have a keyboard shortcut. Use standard shortcuts for standard actions (Cmd+C, Cmd+V, Cmd+Z, etc.). Custom shortcuts should use Cmd plus a letter. Reserve Cmd+Shift, Cmd+Option, and Cmd+Ctrl combos for secondary actions.\n\n**Standard Shortcut Reference:**\n\n| Action | Shortcut |\n|--------|----------|\n| New | Cmd+N |\n| Open | Cmd+O |\n| Close | Cmd+W |\n| Save | Cmd+S |\n| Save As | Cmd+Shift+S |\n| Print | Cmd+P |\n| Undo | Cmd+Z |\n| Redo | Cmd+Shift+Z |\n| Cut | Cmd+X |\n| Copy | Cmd+C |\n| Paste | Cmd+V |\n| Select All | Cmd+A |\n| Find | Cmd+F |\n| Find Next | Cmd+G |\n| Preferences/Settings | Cmd+, |\n| Hide App | Cmd+H |\n| Quit | Cmd+Q |\n| Minimize | Cmd+M |\n| Fullscreen | Cmd+Ctrl+F |\n\n### Rule 1.3 — Dynamic Menu Updates\n\nMenu items must reflect current state. Disable items that are not applicable. Update titles to match context (e.g., \"Undo Typing\" not just \"Undo\"). Toggle checkmarks for on/off states.\n\n```swift\n// SwiftUI — Dynamic menu state\nCommandGroup(replacing: .toolbar) {\n    Button(showingSidebar ? \"Hide Sidebar\" : \"Show Sidebar\") {\n        showingSidebar.toggle()\n    }\n    .keyboardShortcut(\"S\", modifiers: [.command, .control])\n}\n```\n\n```swift\n// AppKit — Validate menu items\noverride func validateMenuItem(_ menuItem: NSMenuItem) -> Bool {\n    if menuItem.action == #selector(delete(_:)) {\n        menuItem.title = selectedItems.count > 1 ? \"Delete \\(selectedItems.count) Items\" : \"Delete\"\n        return !selectedItems.isEmpty\n    }\n    return super.validateMenuItem(menuItem)\n}\n```\n\n### Rule 1.4 — Contextual Menus\n\nProvide right-click context menus on all interactive elements. Context menus should contain the most relevant subset of menu bar actions for the clicked element, plus element-specific actions.\n\n```swift\n// SwiftUI\nText(item.name)\n    .contextMenu {\n        Button(\"Rename...\") { rename(item) }\n        Button(\"Duplicate\") { duplicate(item) }\n        Divider()\n        Button(\"Delete\", role: .destructive) { delete(item) }\n    }\n```\n\n### Rule 1.5 — App Menu Structure\n\nThe App menu (leftmost, bold app name) must contain: About, Preferences/Settings (Cmd+,), Services submenu, Hide App (Cmd+H), Hide Others (Cmd+Option+H), Show All, Quit (Cmd+Q). Never rename or remove these standard items.\n\n```swift\n// SwiftUI — Settings scene\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup { ContentView() }\n        Settings { SettingsView() }  // Automatically wired to Cmd+,\n    }\n}\n```\n\n---\n\n## 2. Windows (CRITICAL)\n\nMac users expect full control over window size, position, and lifecycle. An app that fights window management feels fundamentally broken on the Mac.\n\n### Rule 2.1 — Resizable with Sensible Minimums\n\nAll main windows must be freely resizable. Set a minimum size that keeps the UI usable. Never set a maximum size unless the content truly cannot scale (rare).\n\n```swift\n// SwiftUI\nWindowGroup {\n    ContentView()\n        .frame(minWidth: 600, minHeight: 400)\n}\n.defaultSize(width: 900, height: 600)\n```\n\n```swift\n// AppKit\nwindow.minSize = NSSize(width: 600, height: 400)\nwindow.setContentSize(NSSize(width: 900, height: 600))\n```\n\n### Rule 2.2 — Support Fullscreen and Split View\n\nOpt into native fullscreen by setting the appropriate window collection behavior. The green traffic-light button must either enter fullscreen or show the tile picker.\n\n```swift\n// AppKit\nwindow.collectionBehavior.insert(.fullScreenPrimary)\n```\n\nSwiftUI windows get fullscreen support automatically.\n\n### Rule 2.3 — Multiple Windows\n\nUnless your app is a single-purpose utility, support multiple windows. Document-based apps must allow multiple documents open simultaneously. Use `WindowGroup` or `DocumentGroup` in SwiftUI.\n\n```swift\n// SwiftUI — Document-based app\n@main\nstruct TextEditorApp: App {\n    var body: some Scene {\n        DocumentGroup(newDocument: TextDocument()) { file in\n            TextEditorView(document: file.$document)\n        }\n    }\n}\n```\n\n### Rule 2.4 — Title Bar Shows Document Info\n\nFor document-based apps, the title bar must show the document name. Support proxy icon dragging. Show edited state (dot in close button). Support title bar renaming on click.\n\n```swift\n// AppKit\nwindow.representedURL = document.fileURL\nwindow.title = document.displayName\nwindow.isDocumentEdited = document.hasUnsavedChanges\n```\n\n```swift\n// SwiftUI — NavigationSplitView titles\nNavigationSplitView {\n    SidebarView()\n} detail: {\n    DetailView()\n        .navigationTitle(document.name)\n}\n```\n\n### Rule 2.5 — Remember Window State\n\nPersist window position, size, and state across launches. Use `NSWindow.setFrameAutosaveName` or SwiftUI's built-in state restoration.\n\n```swift\n// AppKit\nwindow.setFrameAutosaveName(\"MainWindow\")\n\n// SwiftUI — Automatic with WindowGroup\nWindowGroup(id: \"main\") {\n    ContentView()\n}\n.defaultPosition(.center)\n```\n\n### Rule 2.6 — Traffic Light Buttons\n\nNever hide or reposition the close (red), minimize (yellow), or zoom (green) buttons. They must remain in the top-left corner. If using a custom title bar, the buttons must still be visible and functional.\n\n```swift\n// AppKit — Custom title bar that preserves traffic lights\nwindow.titlebarAppearsTransparent = true\nwindow.styleMask.insert(.fullSizeContentView)\n// Traffic lights remain functional and visible\n```\n\n---\n\n## 3. Toolbars (HIGH)\n\nToolbars are the secondary command surface after the menu bar. They provide quick access to frequent actions and should be customizable.\n\n### Rule 3.1 — Unified Title Bar and Toolbar\n\nUse the unified title bar + toolbar style for a modern appearance. The toolbar sits in the title bar area, saving vertical space.\n\n```swift\n// SwiftUI\nWindowGroup {\n    ContentView()\n        .toolbar {\n            ToolbarItem(placement: .primaryAction) {\n                Button(action: compose) {\n                    Label(\"Compose\", systemImage: \"square.and.pencil\")\n                }\n            }\n        }\n}\n.windowToolbarStyle(.unified)\n```\n\n```swift\n// AppKit\nwindow.titleVisibility = .hidden\nwindow.toolbarStyle = .unified\n```\n\n### Rule 3.2 — User-Customizable Toolbars\n\nAllow users to add, remove, and rearrange toolbar items. Provide a default set and a superset of available items.\n\n```swift\n// SwiftUI — Customizable toolbar\n.toolbar(id: \"main\") {\n    ToolbarItem(id: \"compose\", placement: .primaryAction) {\n        Button(action: compose) {\n            Label(\"Compose\", systemImage: \"square.and.pencil\")\n        }\n    }\n    ToolbarItem(id: \"filter\", placement: .secondaryAction) {\n        Button(action: toggleFilter) {\n            Label(\"Filter\", systemImage: \"line.3.horizontal.decrease\")\n        }\n    }\n}\n.toolbarRole(.editor)\n```\n\n### Rule 3.3 — Segmented Controls for View Switching\n\nUse a segmented control or picker in the toolbar for switching between content views (e.g., List/Grid/Column). This is a toolbar pattern, not a tab bar.\n\n```swift\n// SwiftUI\nToolbarItem(placement: .principal) {\n    Picker(\"View Mode\", selection: $viewMode) {\n        Label(\"List\", systemImage: \"list.bullet\").tag(ViewMode.list)\n        Label(\"Grid\", systemImage: \"square.grid.2x2\").tag(ViewMode.grid)\n        Label(\"Column\", systemImage: \"rectangle.split.3x1\").tag(ViewMode.column)\n    }\n    .pickerStyle(.segmented)\n}\n```\n\n### Rule 3.4 — Search Field in Toolbar\n\nPlace the search field in the trailing area of the toolbar. Use `.searchable()` in SwiftUI for standard search behavior with suggestions and tokens.\n\n```swift\n// SwiftUI\nNavigationSplitView {\n    SidebarView()\n} detail: {\n    ContentListView()\n        .searchable(text: $searchText, placement: .toolbar, prompt: \"Search items\")\n        .searchSuggestions {\n            ForEach(suggestions) { suggestion in\n                Text(suggestion.title).searchCompletion(suggestion.title)\n            }\n        }\n}\n```\n\n### Rule 3.5 — Toolbar Labels and Icons\n\nToolbar items should have both an icon (SF Symbol) and a text label. In compact mode, show icons only. Prefer labeled icons for discoverability. Use `Label` to supply both.\n\n---\n\n## 4. Sidebars (HIGH)\n\nSidebars are the primary navigation surface for Mac apps. They appear on the leading edge and provide persistent access to top-level sections and content libraries.\n\n### Rule 4.1 — Leading Edge, Collapsible\n\nPlace the sidebar on the left (leading) edge. Make it collapsible via the toolbar button or Cmd+Ctrl+S. Persist collapsed state.\n\n```swift\n// SwiftUI\nNavigationSplitView(columnVisibility: $columnVisibility) {\n    List(selection: $selection) {\n        Section(\"Library\") {\n            Label(\"All Items\", systemImage: \"tray.full\")\n            Label(\"Favorites\", systemImage: \"star\")\n            Label(\"Recent\", systemImage: \"clock\")\n        }\n        Section(\"Tags\") {\n            ForEach(tags) { tag in\n                Label(tag.name, systemImage: \"tag\")\n            }\n        }\n    }\n    .navigationSplitViewColumnWidth(min: 180, ideal: 220, max: 320)\n} detail: {\n    DetailView(selection: selection)\n}\n.navigationSplitViewStyle(.prominentDetail)\n```\n\n### Rule 4.2 — Source List Style\n\nUse the source list style (`.listStyle(.sidebar)`) for content-library navigation. Source lists have a translucent background that shows the desktop or window behind them with vibrancy effects.\n\n```swift\n// SwiftUI\nList(selection: $selection) {\n    ForEach(sections) { section in\n        Section(section.name) {\n            ForEach(section.items) { item in\n                NavigationLink(value: item) {\n                    Label(item.name, systemImage: item.icon)\n                }\n            }\n        }\n    }\n}\n.listStyle(.sidebar)\n```\n\n### Rule 4.3 — Outline Views for Hierarchies\n\nWhen content is hierarchical (e.g., folder trees, project structures), use disclosure groups or outline views to let users expand and collapse levels.\n\n```swift\n// SwiftUI — Recursive outline\nList(selection: $selection) {\n    OutlineGroup(rootNodes, children: \\.children) { node in\n        Label(node.name, systemImage: node.icon)\n    }\n}\n```\n\n### Rule 4.4 — Drag to Reorder\n\nSidebar items that can be reordered (bookmarks, favorites, custom sections) must support drag-to-reorder. Implement `onMove` or `NSOutlineView` drag delegates.\n\n```swift\n// SwiftUI\nForEach(favorites) { item in\n    Label(item.name, systemImage: item.icon)\n}\n.onMove { source, destination in\n    favorites.move(fromOffsets: source, toOffset: destination)\n}\n```\n\n### Rule 4.5 — Badge Counts\n\nShow badge counts on sidebar items for unread counts, pending items, or notifications. Use the `.badge()` modifier.\n\n```swift\n// SwiftUI\nLabel(\"Inbox\", systemImage: \"tray\")\n    .badge(unreadCount)\n```\n\n---\n\n## 5. Keyboard (CRITICAL)\n\nMac users rely on keyboard shortcuts more than any other platform. An app without comprehensive keyboard support is a broken Mac app.\n\n### Rule 5.1 — Cmd Shortcuts for Everything\n\nEvery action reachable by mouse must have a keyboard equivalent. Primary actions use Cmd+letter. Secondary actions use Cmd+Shift or Cmd+Option. Tertiary actions use Cmd+Ctrl.\n\n**Keyboard Shortcut Conventions:**\n\n| Modifier Pattern | Usage |\n|-----------------|-------|\n| Cmd+letter | Primary actions (New, Open, Save, etc.) |\n| Cmd+Shift+letter | Variant of primary (Save As, Find Previous) |\n| Cmd+Option+letter | Alternative mode (Paste and Match Style) |\n| Cmd+Ctrl+letter | Window/view controls (Fullscreen, Sidebar) |\n| Ctrl+letter | Emacs-style text navigation (acceptable) |\n| Fn+key | System functions (F11 Show Desktop, etc.) |\n\n### Rule 5.2 — Full Keyboard Navigation\n\nSupport Tab to move between controls. Support arrow keys within lists, grids, and tables. Support Shift+Tab for reverse navigation. Use `focusable()` and `@FocusState` in SwiftUI.\n\n```swift\n// SwiftUI — Focus management\nstruct ContentView: View {\n    @FocusState private var focusedField: Field?\n\n    var body: some View {\n        VStack {\n            TextField(\"Name\", text: $name)\n                .focused($focusedField, equals: .name)\n            TextField(\"Email\", text: $email)\n                .focused($focusedField, equals: .email)\n        }\n        .onSubmit { advanceFocus() }\n    }\n}\n```\n\n### Rule 5.3 — Escape to Cancel or Close\n\nEsc must dismiss popovers, sheets, dialogs, and cancel in-progress operations. In text fields, Esc reverts to the previous value. In modal dialogs, Esc is equivalent to clicking Cancel.\n\n```swift\n// SwiftUI — Sheet with Esc support (automatic)\n.sheet(isPresented: $showingSheet) {\n    SheetView()  // Esc dismisses automatically\n}\n\n// AppKit — Custom responder\noverride func cancelOperation(_ sender: Any?) {\n    dismiss(nil)\n}\n```\n\n### Rule 5.4 — Return for Default Action\n\nIn dialogs and forms, Return/Enter activates the default button (visually emphasized in blue). The default button is always the safest primary action.\n\n```swift\n// SwiftUI\nButton(\"Save\") { save() }\n    .keyboardShortcut(.defaultAction)  // Enter key\n\nButton(\"Cancel\") { cancel() }\n    .keyboardShortcut(.cancelAction)   // Esc key\n```\n\n### Rule 5.5 — Delete for Removal\n\nThe Delete key (Backspace) must remove selected items in lists, tables, and collections. Cmd+Delete for more destructive removal (move to Trash). Always support Cmd+Z to undo deletion.\n\n### Rule 5.6 — Space for Quick Look\n\nWhen items support previewing, Space bar should invoke Quick Look. Use the `QLPreviewPanel` API in AppKit or `.quickLookPreview()` in SwiftUI.\n\n```swift\n// SwiftUI\nList(selection: $selection) {\n    ForEach(files) { file in\n        FileRow(file: file)\n    }\n}\n.quickLookPreview($quickLookItem, in: files)\n```\n\n### Rule 5.7 — Arrow Key Navigation\n\nIn lists and grids, Up/Down arrow keys move selection. Left/Right collapse/expand disclosure groups or navigate columns. Cmd+Up goes to the beginning, Cmd+Down goes to the end.\n\n---\n\n## 6. Pointer and Mouse (HIGH)\n\nMac is a pointer-driven platform. Every interactive element must respond to hover, click, right-click, and drag.\n\n### Rule 6.1 — Hover States\n\nAll interactive elements must have a visible hover state. Buttons highlight, rows show a selection indicator, links change cursor. Use `.onHover` in SwiftUI.\n\n```swift\n// SwiftUI — Hover effect\nstruct HoverableRow: View {\n    @State private var isHovered = false\n\n    var body: some View {\n        HStack {\n            Text(item.name)\n            Spacer()\n            if isHovered {\n                Button(\"Edit\") { edit() }\n                    .buttonStyle(.borderless)\n            }\n        }\n        .padding(8)\n        .background(isHovered ? Color.primary.opacity(0.05) : .clear)\n        .cornerRadius(6)\n        .onHover { hovering in isHovered = hovering }\n    }\n}\n```\n\n### Rule 6.2 — Right-Click Context Menus\n\nEvery interactive element must respond to right-click with a contextual menu. The context menu should contain the most relevant actions for the clicked item.\n\n### Rule 6.3 — Drag and Drop\n\nSupport drag and drop for content manipulation: reordering items, moving between containers, importing files from Finder, and exporting content.\n\n```swift\n// SwiftUI — Drag and drop\nForEach(items) { item in\n    ItemView(item: item)\n        .draggable(item)\n}\n.dropDestination(for: Item.self) { items, location in\n    handleDrop(items, at: location)\n    return true\n}\n```\n\n```swift\n// Accepting file drops from Finder\n.dropDestination(for: URL.self) { urls, location in\n    importFiles(urls)\n    return true\n}\n```\n\n### Rule 6.4 — Scroll Behavior\n\nSupport both trackpad (smooth/inertial) and mouse wheel (discrete) scrolling. Use elastic/bounce scrolling at content boundaries. Support horizontal scrolling where appropriate.\n\n### Rule 6.5 — Cursor Changes\n\nChange the cursor to indicate affordances: pointer for clickable elements, I-beam for text, crosshair for drawing, resize handles at window/splitter edges, grab hand for draggable content.\n\n```swift\n// AppKit — Custom cursor\noverride func resetCursorRects() {\n    addCursorRect(bounds, cursor: .crosshair)\n}\n```\n\n### Rule 6.6 — Multi-Selection\n\nSupport Cmd+Click for non-contiguous selection and Shift+Click for range selection in lists, tables, and grids. This is a deeply ingrained Mac interaction pattern.\n\n```swift\n// SwiftUI — Tables with multi-selection\nTable(items, selection: $selectedItems) {\n    TableColumn(\"Name\", value: \\.name)\n    TableColumn(\"Date\", value: \\.dateFormatted)\n    TableColumn(\"Size\", value: \\.sizeFormatted)\n}\n```\n\n---\n\n## 7. Notifications and Alerts (MEDIUM)\n\nMac users are protective of their attention. Only interrupt when truly necessary.\n\n### Rule 7.1 — Use Notification Center Appropriately\n\nSend notifications only for events that happen outside the app or require user action. Never notify for routine operations. Notifications must be actionable.\n\n```swift\n// UserNotifications\nlet content = UNMutableNotificationContent()\ncontent.title = \"Download Complete\"\ncontent.body = \"project-assets.zip is ready\"\ncontent.categoryIdentifier = \"DOWNLOAD\"\ncontent.sound = .default\n\nlet request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: nil)\nUNUserNotificationCenter.current().add(request)\n```\n\n### Rule 7.2 — Alerts with Suppression Option\n\nFor recurring alerts, provide a \"Do not show this again\" checkbox. Respect the user's choice and persist it.\n\n```swift\n// AppKit — Alert with suppression\nlet alert = NSAlert()\nalert.messageText = \"Remove from library?\"\nalert.informativeText = \"The file will be moved to the Trash.\"\nalert.alertStyle = .warning\nalert.addButton(withTitle: \"Remove\")\nalert.addButton(withTitle: \"Cancel\")\nalert.showsSuppressionButton = true\nalert.suppressionButton?.title = \"Do not ask again\"\n\nlet response = alert.runModal()\nif alert.suppressionButton?.state == .on {\n    UserDefaults.standard.set(true, forKey: \"suppressRemoveAlert\")\n}\n```\n\n### Rule 7.3 — Don't Interrupt Unnecessarily\n\nNever show alerts for successful operations. Use inline status indicators, toolbar badges, or subtle animations instead. Reserve modal alerts for destructive or irreversible actions.\n\n### Rule 7.4 — Dock Badge\n\nShow a badge on the Dock icon for notification counts. Clear it promptly when the user addresses the notifications.\n\n```swift\n// AppKit\nNSApp.dockTile.badgeLabel = unreadCount > 0 ? \"\\(unreadCount)\" : nil\n```\n\n---\n\n## 8. System Integration (MEDIUM)\n\nMac apps exist in a rich ecosystem. Deep integration makes an app feel native.\n\n### Rule 8.1 — Dock Icon and Menus\n\nProvide a high-quality 1024x1024 app icon. Support Dock right-click menus for quick actions. Show recent documents in the Dock menu.\n\n```swift\n// AppKit — Dock menu\noverride func applicationDockMenu(_ sender: NSApplication) -> NSMenu? {\n    let menu = NSMenu()\n    menu.addItem(withTitle: \"New Window\", action: #selector(newWindow(_:)), keyEquivalent: \"\")\n    menu.addItem(withTitle: \"New Document\", action: #selector(newDocument(_:)), keyEquivalent: \"\")\n    menu.addItem(.separator())\n    for doc in recentDocuments.prefix(5) {\n        menu.addItem(withTitle: doc.name, action: #selector(openRecent(_:)), keyEquivalent: \"\")\n    }\n    return menu\n}\n```\n\n### Rule 8.2 — Spotlight Integration\n\nIndex app content for Spotlight search using `CSSearchableItem` and Core Spotlight. Users expect to find app content via Cmd+Space.\n\n```swift\nimport CoreSpotlight\n\nlet attributeSet = CSSearchableItemAttributeSet(contentType: .text)\nattributeSet.title = document.title\nattributeSet.contentDescription = document.summary\nattributeSet.thumbnailData = document.thumbnail?.pngData()\n\nlet item = CSSearchableItem(uniqueIdentifier: document.id, domainIdentifier: \"documents\", attributeSet: attributeSet)\nCSSearchableIndex.default().indexSearchableItems([item])\n```\n\n### Rule 8.3 — Quick Look Support\n\nProvide Quick Look previews for custom file types via a Quick Look Preview Extension. Users expect Space to preview any file in Finder.\n\n### Rule 8.4 — Share Extensions\n\nImplement the Share menu so users can share content from your app to Messages, Mail, Notes, etc. Also accept shared content from other apps.\n\n```swift\n// SwiftUI\nShareLink(item: document.url) {\n    Label(\"Share\", systemImage: \"square.and.arrow.up\")\n}\n```\n\n### Rule 8.5 — Services Menu\n\nRegister for the Services menu to receive text, URLs, or files from other apps. This is a uniquely Mac integration point that power users rely on.\n\n### Rule 8.6 — Shortcuts and AppleScript\n\nSupport the Shortcuts app by providing App Intents. For advanced automation, add AppleScript/JXA scripting support via an `.sdef` scripting dictionary.\n\n```swift\n// App Intents for Shortcuts\nstruct CreateDocumentIntent: AppIntent {\n    static var title: LocalizedStringResource = \"Create Document\"\n    static var description = IntentDescription(\"Creates a new document with the given title.\")\n\n    @Parameter(title: \"Title\")\n    var title: String\n\n    func perform() async throws -> some IntentResult {\n        let doc = DocumentManager.shared.create(title: title)\n        return .result(value: doc.title)\n    }\n}\n```\n\n---\n\n## 9. Visual Design (HIGH)\n\nMac apps should look and feel like they belong on the platform. Use system-provided materials, fonts, and colors.\n\n### Rule 9.1 — Use System Fonts\n\nUse SF Pro (the system font) at standard dynamic type sizes. Use SF Mono for code. Never hardcode font sizes; use semantic styles.\n\n```swift\n// SwiftUI — Semantic font styles\nText(\"Title\").font(.title)\nText(\"Headline\").font(.headline)\nText(\"Body text\").font(.body)\nText(\"Caption\").font(.caption)\nText(\"let x = 42\").font(.system(.body, design: .monospaced))\n```\n\n### Rule 9.2 — Vibrancy and Materials\n\nUse system materials for sidebar and toolbar backgrounds. Vibrancy lets the desktop or underlying content show through, anchoring the app to the Mac visual language.\n\n```swift\n// SwiftUI\nList { ... }\n    .listStyle(.sidebar)  // Automatic vibrancy\n\n// Custom vibrancy\nZStack {\n    VisualEffectView(material: .sidebar, blendingMode: .behindWindow)\n    Text(\"Sidebar Content\")\n}\n```\n\n```swift\n// AppKit — Visual effect view\nlet visualEffect = NSVisualEffectView()\nvisualEffect.material = .sidebar\nvisualEffect.blendingMode = .behindWindow\nvisualEffect.state = .followsWindowActiveState\n```\n\n### Rule 9.3 — Respect System Accent Color\n\nUse the system accent color for selection, emphasis, and interactive elements. Never override it with a fixed brand color for standard controls. Use `.accentColor` or `.tint` only on custom views when appropriate.\n\n```swift\n// SwiftUI — Follows system accent automatically\nButton(\"Action\") { doSomething() }\n    .buttonStyle(.borderedProminent)  // Uses system accent color\n\nToggle(\"Enable feature\", isOn: $isEnabled)  // Toggle tint follows accent\n```\n\n### Rule 9.4 — Support Dark Mode\n\nEvery view must support both Light and Dark appearances. Use semantic colors (`Color.primary`, `Color.secondary`, `.background`) rather than hardcoded colors. Test in both modes.\n\n```swift\n// SwiftUI — Semantic colors\nText(\"Title\").foregroundStyle(.primary)\nText(\"Subtitle\").foregroundStyle(.secondary)\n\nRoundedRectangle(cornerRadius: 8)\n    .fill(Color(nsColor: .controlBackgroundColor))\n\n// Asset catalog: define colors for Both Appearances\n// Never use Color.white or Color.black for UI surfaces\n```\n\n### Rule 9.5 — Translucency\n\nRespect the \"Reduce transparency\" accessibility setting. When transparency is reduced, replace translucent materials with solid backgrounds.\n\n```swift\n// SwiftUI\n@Environment(\\.accessibilityReduceTransparency) var reduceTransparency\n\nvar body: some View {\n    if reduceTransparency {\n        Color(nsColor: .windowBackgroundColor)\n    } else {\n        VisualEffectView(material: .sidebar, blendingMode: .behindWindow)\n    }\n}\n```\n\n### Rule 9.6 — Consistent Spacing and Layout\n\nUse 20pt standard margins, 8pt spacing between related controls, 20pt spacing between groups. Align controls to a grid. Use SwiftUI's built-in spacing or AppKit's Auto Layout with system spacing constraints.\n\n---\n\n## Keyboard Shortcut Quick Reference\n\n### Navigation\n| Shortcut | Action |\n|----------|--------|\n| Cmd+N | New window/document |\n| Cmd+O | Open |\n| Cmd+W | Close window/tab |\n| Cmd+Q | Quit app |\n| Cmd+, | Settings/Preferences |\n| Cmd+Tab | Switch apps |\n| Cmd+` | Switch windows within app |\n| Cmd+T | New tab |\n\n### Editing\n| Shortcut | Action |\n|----------|--------|\n| Cmd+Z | Undo |\n| Cmd+Shift+Z | Redo |\n| Cmd+X / C / V | Cut / Copy / Paste |\n| Cmd+A | Select All |\n| Cmd+D | Duplicate |\n| Cmd+F | Find |\n| Cmd+G | Find Next |\n| Cmd+Shift+G | Find Previous |\n| Cmd+E | Use Selection for Find |\n\n### View\n| Shortcut | Action |\n|----------|--------|\n| Cmd+Ctrl+F | Toggle fullscreen |\n| Cmd+Ctrl+S | Toggle sidebar |\n| Cmd+0 | Show/hide toolbar |\n| Cmd++ / Cmd+- | Zoom in/out |\n| Cmd+0 | Actual size |\n\n---\n\n## Evaluation Checklist\n\nBefore shipping a Mac app, verify:\n\n### Menu Bar\n- [ ] App has a complete menu bar with standard menus\n- [ ] All actions have keyboard shortcuts\n- [ ] Menu items dynamically update (enable/disable, title changes)\n- [ ] Context menus on all interactive elements\n- [ ] App menu has About, Settings, Hide, Quit\n\n### Windows\n- [ ] Windows are freely resizable with sensible minimums\n- [ ] Fullscreen and Split View work\n- [ ] Multiple windows supported (if appropriate)\n- [ ] Window position and size persist across launches\n- [ ] Traffic light buttons visible and functional\n- [ ] Document title and edited state shown (if document-based)\n\n### Toolbars\n- [ ] Toolbar present with common actions\n- [ ] Toolbar is user-customizable\n- [ ] Search field available in toolbar\n\n### Sidebars\n- [ ] Sidebar for navigation (if app has multiple sections)\n- [ ] Sidebar is collapsible\n- [ ] Source list style with vibrancy\n\n### Keyboard\n- [ ] Full keyboard navigation (Tab, arrows, Enter, Esc)\n- [ ] Cmd+Z undo for all destructive actions\n- [ ] Space for Quick Look previews\n- [ ] Delete key removes selected items\n- [ ] No keyboard traps (user can always Tab out)\n\n### Pointer\n- [ ] Hover states on interactive elements\n- [ ] Right-click context menus everywhere\n- [ ] Drag and drop for content manipulation\n- [ ] Cmd+Click for multi-selection\n- [ ] Appropriate cursor changes\n\n### Notifications\n- [ ] Notifications only for important events\n- [ ] Alerts have suppression option for recurring ones\n- [ ] No modal alerts for routine operations\n\n### System Integration\n- [ ] High-quality Dock icon\n- [ ] Content indexed in Spotlight (if applicable)\n- [ ] Share menu works\n- [ ] App Intents for Shortcuts\n\n### Visual Design\n- [ ] System fonts at semantic sizes\n- [ ] Dark Mode fully supported\n- [ ] System accent color respected\n- [ ] Translucency respects accessibility setting\n- [ ] Consistent spacing on 8pt grid\n\n---\n\n## Anti-Patterns\n\n**Do not do these things in a Mac app:**\n\n1. **No menu bar** — Every Mac app needs a menu bar. Period. A Mac app without menus is like a car without a steering wheel.\n\n2. **Hamburger menus** — Never use a hamburger menu on Mac. The menu bar exists for this purpose. Hamburger menus signal a lazy iOS port.\n\n3. **Tab bars at the bottom** — Mac apps use sidebars and toolbars, not iOS-style tab bars. If you need tabs, use actual document tabs in the tab bar (like Safari or Finder).\n\n4. **Large touch-sized targets** — Mac controls should be compact (22-28pt height). Users have precise pointer input. Giant buttons waste space and look out of place.\n\n5. **Floating action buttons** — FABs are a Material Design pattern. On Mac, place primary actions in the toolbar, menu bar, or as inline buttons.\n\n6. **Sheet for every action** — Don't use modal sheets for simple operations. Use popovers, inline editing, or direct manipulation. Sheets should be reserved for multi-step workflows or important decisions.\n\n7. **Custom window chrome** — Don't replace the standard title bar, traffic lights, or window controls with custom implementations. Users expect these to work consistently across all apps.\n\n8. **Ignoring keyboard** — If a power user must reach for the mouse to perform common actions, your keyboard support is insufficient.\n\n9. **Single-window only** — Unless your app is genuinely single-purpose (calculator, timer), support multiple windows. Users expect to Cmd+N for new windows.\n\n10. **Fixed window size** — Non-resizable windows feel broken on Mac. Users have displays ranging from 13\" laptops to 32\" externals and expect to use that space.\n\n11. **No Cmd+Z undo** — Every destructive or modifying action must be undoable. Users build muscle memory around Cmd+Z as their safety net.\n\n12. **Notification spam** — Mac apps that send excessive notifications get their permissions revoked. Only notify for events that genuinely need attention.\n\n13. **Ignoring Dark Mode** — A Mac app that looks wrong in Dark Mode appears abandoned. Always test both appearances.\n\n14. **Hardcoded colors** — Use semantic system colors, not hardcoded hex values. Your colors should adapt to Light/Dark mode and accessibility settings automatically.\n\n15. **No drag and drop** — Mac is a drag-and-drop platform. If users can see content, they expect to drag it somewhere.","toolStatus":"completed","toolIntent":"Get the SKILL.md content for the macOS design guidelines skill","toolDisplayName":"Fetch macOS SKILL.md","toolDisplayMeta":{"displayName":"Fetch URL","category":"native"},"isError":false,"turnId":"msg_01NLRZgu2G9Fb2YLQRs1MDup"}
{"id":"msg-1771300628540-w6dqjz","type":"tool","content":"Based on the webpage content provided, the directory listing for `skills/macos` shows only **4 items**:\n\n1. `rules` (directory)\n2. `AGENTS.md` (file)\n3. `SKILL.md` (file)\n4. `metadata.json` (file)\n\n**There is no icon file** (icon.svg, icon.png, etc.) listed in this directory.","timestamp":1771300628540,"toolName":"WebFetch","toolUseId":"toolu_015CsV2XQRGgDB5uivR3TGX9","toolInput":{"url":"https://github.com/ehmo/platform-design-skills/tree/main/skills/macos","prompt":"List ALL files in this directory. I need to know if there's an icon file (icon.svg, icon.png, etc.)"},"toolResult":"Based on the webpage content provided, the directory listing for `skills/macos` shows only **4 items**:\n\n1. `rules` (directory)\n2. `AGENTS.md` (file)\n3. `SKILL.md` (file)\n4. `metadata.json` (file)\n\n**There is no icon file** (icon.svg, icon.png, etc.) listed in this directory.","toolStatus":"completed","toolIntent":"Check if there's an icon file for the macOS skill","toolDisplayName":"Check macOS Icon","toolDisplayMeta":{"displayName":"Fetch URL","category":"native"},"isError":false,"turnId":"msg_01NLRZgu2G9Fb2YLQRs1MDup"}
{"id":"msg-1771300721487-ivqlrn","type":"tool","content":"---\nname: macos-design-guidelines\ndescription: Apple Human Interface Guidelines for Mac. Use when building macOS apps with SwiftUI or AppKit, implementing menu bars, toolbars, window management, or keyboard shortcuts. Triggers on tasks involving Mac UI, desktop apps, or Mac Catalyst.\nlicense: MIT\nmetadata:\n  author: platform-design-skills\n  version: \"1.0.0\"\n---\n\n# macOS Human Interface Guidelines\n\nMac apps serve power users who expect deep keyboard control, persistent menu bars, resizable multi-window layouts, and tight system integration. These guidelines codify Apple's HIG into actionable rules with SwiftUI and AppKit examples.\n\n---\n\n## 1. Menu Bar (CRITICAL)\n\nEvery Mac app must have a menu bar. It is the primary discovery mechanism for commands. Users who cannot find a feature will look in the menu bar before anywhere else.\n\n### Rule 1.1 — Provide Standard Menus","timestamp":1771300721487,"toolName":"Bash","toolUseId":"toolu_01GK98doN7qXZ7GBRcW7SP8g","toolInput":{"command":"curl -sL https://raw.githubusercontent.com/ehmo/platform-design-skills/main/skills/macos/SKILL.md | head -20"},"toolResult":"---\nname: macos-design-guidelines\ndescription: Apple Human Interface Guidelines for Mac. Use when building macOS apps with SwiftUI or AppKit, implementing menu bars, toolbars, window management, or keyboard shortcuts. Triggers on tasks involving Mac UI, desktop apps, or Mac Catalyst.\nlicense: MIT\nmetadata:\n  author: platform-design-skills\n  version: \"1.0.0\"\n---\n\n# macOS Human Interface Guidelines\n\nMac apps serve power users who expect deep keyboard control, persistent menu bars, resizable multi-window layouts, and tight system integration. These guidelines codify Apple's HIG into actionable rules with SwiftUI and AppKit examples.\n\n---\n\n## 1. Menu Bar (CRITICAL)\n\nEvery Mac app must have a menu bar. It is the primary discovery mechanism for commands. Users who cannot find a feature will look in the menu bar before anywhere else.\n\n### Rule 1.1 — Provide Standard Menus","toolStatus":"completed","toolIntent":"Get the raw SKILL.md file including YAML frontmatter","toolDisplayName":"Download Raw SKILL.md","toolDisplayMeta":{"displayName":"curl","iconDataUrl":"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDIxIDg1NCI+CiA8ZyBmaWxsPSJub25lIiBzdHJva2U9IiMwOTM3NTQiIHN0cm9rZS13aWR0aD0iMzQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE3IDE3KSI+CiAgPGNpcmNsZSBjeD0iNTgiIGN5PSI1MjkiIHI9IjU4Ii8+CiAgPGNpcmNsZSBjeD0iNTgiIGN5PSIyNjMiIHI9IjU4Ii8+CiAgPHBhdGggc3Ryb2tlLXdpZHRoPSIxMDAiIGQ9Ik01OTYgMTAxIDIzNCA3MjEiLz4KICA8Y2lyY2xlIGN4PSIyMTAiIGN5PSI3NjIiIHI9IjU4Ii8+CiAgPGNpcmNsZSBjeD0iNjIxIiBjeT0iNTgiIHI9IjU4Ii8+CiAgPGcgc3Ryb2tlPSIjMGY1NjRkIj4KICAgPHBhdGggc3Ryb2tlLXdpZHRoPSIxMDAiIGQ9Ik05MDQgMTAxIDU0MiA3MjEiLz4KICAgPGNpcmNsZSBjeD0iOTI5IiBjeT0iNTgiIHI9IjU4Ii8+CiAgIDxjaXJjbGUgY3g9IjUxOCIgY3k9Ijc2MiIgcj0iNTgiLz4KICA8L2c+CiA8L2c+Cjwvc3ZnPgo=","category":"native"},"isError":false,"turnId":"msg_013u8ATFEDztB9A9rWzYK74c"}
{"id":"msg-1771300728849-7gutv2","type":"tool","content":"     965 ./Users/andresilvagomez/Projects/wisper/skills/macos-design-guidelines/SKILL.md","timestamp":1771300728849,"toolName":"Bash","toolUseId":"toolu_01SMGyHnegsGUhG6cktSxg32","toolInput":{"command":"mkdir -p ./Users/andresilvagomez/Projects/wisper/skills/macos-design-guidelines && curl -sL https://raw.githubusercontent.com/ehmo/platform-design-skills/main/skills/macos/SKILL.md -o ./Users/andresilvagomez/Projects/wisper/skills/macos-design-guidelines/SKILL.md && wc -l ./Users/andresilvagomez/Projects/wisper/skills/macos-design-guidelines/SKILL.md","description":"Create skill folder and download SKILL.md from GitHub"},"toolResult":"     965 ./Users/andresilvagomez/Projects/wisper/skills/macos-design-guidelines/SKILL.md","toolStatus":"completed","toolIntent":"Create the macos-design-guidelines skill folder and download the SKILL.md","toolDisplayName":"Create Skill Directory","toolDisplayMeta":{"displayName":"curl","iconDataUrl":"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDIxIDg1NCI+CiA8ZyBmaWxsPSJub25lIiBzdHJva2U9IiMwOTM3NTQiIHN0cm9rZS13aWR0aD0iMzQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE3IDE3KSI+CiAgPGNpcmNsZSBjeD0iNTgiIGN5PSI1MjkiIHI9IjU4Ii8+CiAgPGNpcmNsZSBjeD0iNTgiIGN5PSIyNjMiIHI9IjU4Ii8+CiAgPHBhdGggc3Ryb2tlLXdpZHRoPSIxMDAiIGQ9Ik01OTYgMTAxIDIzNCA3MjEiLz4KICA8Y2lyY2xlIGN4PSIyMTAiIGN5PSI3NjIiIHI9IjU4Ii8+CiAgPGNpcmNsZSBjeD0iNjIxIiBjeT0iNTgiIHI9IjU4Ii8+CiAgPGcgc3Ryb2tlPSIjMGY1NjRkIj4KICAgPHBhdGggc3Ryb2tlLXdpZHRoPSIxMDAiIGQ9Ik05MDQgMTAxIDU0MiA3MjEiLz4KICAgPGNpcmNsZSBjeD0iOTI5IiBjeT0iNTgiIHI9IjU4Ii8+CiAgIDxjaXJjbGUgY3g9IjUxOCIgY3k9Ijc2MiIgcj0iNTgiLz4KICA8L2c+CiA8L2c+Cjwvc3ZnPgo=","category":"native"},"isError":false,"turnId":"msg_01SWC3X4zJt3YLAc8Q8UC8Kj"}
{"id":"msg-1771300734222-td61ki","type":"tool","content":"File created successfully at: ./Users/andresilvagomez/Projects/wisper/skills/macos-design-guidelines/icon.svg","timestamp":1771300734222,"toolName":"Write","toolUseId":"toolu_01KzSYXqpJoVTv8LaPbxAwd8","toolInput":{"file_path":"./Users/andresilvagomez/Projects/wisper/skills/macos-design-guidelines/icon.svg","content":"<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n  <rect x=\"2\" y=\"3\" width=\"20\" height=\"14\" rx=\"2\" ry=\"2\"/>\n  <line x1=\"8\" y1=\"21\" x2=\"16\" y2=\"21\"/>\n  <line x1=\"12\" y1=\"17\" x2=\"12\" y2=\"21\"/>\n</svg>"},"toolResult":"File created successfully at: ./Users/andresilvagomez/Projects/wisper/skills/macos-design-guidelines/icon.svg","toolStatus":"completed","toolIntent":"Create an SVG icon representing macOS (Apple logo style) for the skill","toolDisplayName":"Write macOS Icon","toolDisplayMeta":{"displayName":"Write","category":"native"},"isError":false,"turnId":"msg_01Q5E3XLecWdg2Sx5sE2v2gL"}
{"id":"msg-1771300737300-2socyc","type":"tool","content":"[\n  {\n    \"type\": \"text\",\n    \"text\": \"✓ Validation passed\"\n  }\n]","timestamp":1771300737300,"toolName":"mcp__session__skill_validate","toolUseId":"toolu_015RH4QaktDxSwv2MX23ffG1","toolInput":{"skillSlug":"macos-design-guidelines"},"toolResult":"[\n  {\n    \"type\": \"text\",\n    \"text\": \"✓ Validation passed\"\n  }\n]","toolStatus":"completed","toolIntent":"Validate the macos-design-guidelines skill was created correctly","toolDisplayName":"Validate Skill","toolDisplayMeta":{"displayName":"Validate Skill","category":"native"},"isError":false,"turnId":"msg_01Q5E3XLecWdg2Sx5sE2v2gL"}
{"id":"msg-1771300743429-k3ezpw","type":"assistant","content":"\n\nSkill **macos-design-guidelines** instalado correctamente desde [ehmo/platform-design-skills](https://github.com/ehmo/platform-design-skills).\n\n**Contenido:** 965 líneas con las Apple Human Interface Guidelines para macOS — cubre menús, ventanas, toolbars, sidebars, teclado, puntero, notificaciones, integración del sistema y diseño visual, con ejemplos en SwiftUI y AppKit.\n\nInvócalo con `/macos-design-guidelines` cuando estés construyendo apps para macOS.","timestamp":1771300743429,"isIntermediate":false,"turnId":"msg_015wgxrAsXiQ18Ei4qFFFTsk"}
